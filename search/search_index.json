{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DevSecOps command line asset inventory Installing \u00b6 pip install clinv Work in progress Lately I've completely rewritten clinv, I'll update the docs as soon as possible. References \u00b6 As most open sourced programs, clinv is standing on the shoulders of giants, namely: Pytest Testing framework, enhanced by the awesome pytest-cases library that made the parametrization of the tests a lovely experience. Mypy Python static type checker. Flakeheaven Python linter with lots of checks . Black Python formatter to keep a nice style without effort. Autoimport Python formatter to automatically fix wrong import statements. isort Python formatter to order the import statements. Pip-tools Command line tool to manage the dependencies. Mkdocs To build this documentation site, with the Material theme . Safety To check the installed dependencies for known security vulnerabilities. Bandit To finds common security issues in Python code. Yamlfix YAML fixer. Contributing \u00b6 For guidance on setting up a development environment, and how to make a contribution to clinv , see Contributing to clinv .","title":"Clinv"},{"location":"#installing","text":"pip install clinv Work in progress Lately I've completely rewritten clinv, I'll update the docs as soon as possible.","title":"Installing"},{"location":"#references","text":"As most open sourced programs, clinv is standing on the shoulders of giants, namely: Pytest Testing framework, enhanced by the awesome pytest-cases library that made the parametrization of the tests a lovely experience. Mypy Python static type checker. Flakeheaven Python linter with lots of checks . Black Python formatter to keep a nice style without effort. Autoimport Python formatter to automatically fix wrong import statements. isort Python formatter to order the import statements. Pip-tools Command line tool to manage the dependencies. Mkdocs To build this documentation site, with the Material theme . Safety To check the installed dependencies for known security vulnerabilities. Bandit To finds common security issues in Python code. Yamlfix YAML fixer.","title":"References"},{"location":"#contributing","text":"For guidance on setting up a development environment, and how to make a contribution to clinv , see Contributing to clinv .","title":"Contributing"},{"location":"contributing/","text":"So you've started using clinv and want to show your gratitude to the project, depending on your programming skills there are different ways to do so. I don't know how to program \u00b6 There are several ways you can contribute: Open an issue if you encounter any bug or to let us know if you want a new feature to be implemented. Spread the word about the program. Review the documentation and try to improve it. I know how to program in Python \u00b6 If you have some python knowledge there are some additional ways to contribute. We've ordered the issues in milestones , check the issues in the smaller one, as it's where we'll be spending most of our efforts. Try the good first issues , as they are expected to be easier to get into the project. We develop the program with TDD , so we expect any contribution to have it's associated tests. We also try to maintain an updated documentation of the project, so think if your contribution needs to update it. We know that the expected code quality is above average. Therefore it might be changeling to get the initial grasp of the project structure, know how to make the tests, update the documentation or use all the project technology stack. but please don't let this fact discourage you from contributing: If you want to develop a new feature, explain how you'd like to do it in the related issue. If you don't know how to test your code, do the pull request without the tests and we'll try to do them for you. Issues \u00b6 Questions, feature requests and bug reports are all welcome as issues. To report a security vulnerability, please see our security policy instead. To make it as simple as possible for us to help you, please include the output of the following call in your issue: python -c \"import clinv.version; print(clinv.version.version_info())\" or if you have make installed, you can use make version . Please try to always include the above unless you're unable to install clinv or know it's not relevant to your question or feature request. Pull Requests \u00b6 clinv is released regularly so you should see your improvements release in a matter of days or weeks. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. If you're looking for something to get your teeth into, check out the \"help wanted\" label on github. Development facilities \u00b6 To make contributing as easy and fast as possible, you'll want to run tests and linting locally. tl;dr : use make format to fix formatting, make to run tests and linting & make docs to build the docs. You'll need to have python 3.6, 3.7, or 3.8, virtualenv, git, and make installed. Clone your fork and go into the repository directory: git clone git@github.com:<your username>/clinv.git cd clinv Set up the virtualenv for running tests: virtualenv -p ` which python3.7 ` env source env/bin/activate Install clinv, dependencies and configure the pre-commits: make install Checkout a new branch and make your changes: git checkout -b my-new-feature-branch Fix formatting and imports: clinv uses black to enforce formatting and isort to fix imports. make format Run tests and linting: make There are more sub-commands in Makefile like test-code , test-examples , mypy or security which you might want to use, but generally make should be all you need. If you need to pass specific arguments to pytest use the ARGS variable, for example make test ARGs='-k test_markdownlint_passes' . Build documentation: If you have changed the documentation, make sure it builds the static site. Once built it will serve the documentation at localhost:8000 : make docs Commit, push, and create your pull request. Make a new release: To generate the changelog of the new changes, build the package, upload to pypi and clean the build files use make bump . We'd love you to contribute to clinv !","title":"Contributing"},{"location":"contributing/#i-dont-know-how-to-program","text":"There are several ways you can contribute: Open an issue if you encounter any bug or to let us know if you want a new feature to be implemented. Spread the word about the program. Review the documentation and try to improve it.","title":"I don't know how to program"},{"location":"contributing/#i-know-how-to-program-in-python","text":"If you have some python knowledge there are some additional ways to contribute. We've ordered the issues in milestones , check the issues in the smaller one, as it's where we'll be spending most of our efforts. Try the good first issues , as they are expected to be easier to get into the project. We develop the program with TDD , so we expect any contribution to have it's associated tests. We also try to maintain an updated documentation of the project, so think if your contribution needs to update it. We know that the expected code quality is above average. Therefore it might be changeling to get the initial grasp of the project structure, know how to make the tests, update the documentation or use all the project technology stack. but please don't let this fact discourage you from contributing: If you want to develop a new feature, explain how you'd like to do it in the related issue. If you don't know how to test your code, do the pull request without the tests and we'll try to do them for you.","title":"I know how to program in Python"},{"location":"contributing/#issues","text":"Questions, feature requests and bug reports are all welcome as issues. To report a security vulnerability, please see our security policy instead. To make it as simple as possible for us to help you, please include the output of the following call in your issue: python -c \"import clinv.version; print(clinv.version.version_info())\" or if you have make installed, you can use make version . Please try to always include the above unless you're unable to install clinv or know it's not relevant to your question or feature request.","title":"Issues"},{"location":"contributing/#pull-requests","text":"clinv is released regularly so you should see your improvements release in a matter of days or weeks. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. If you're looking for something to get your teeth into, check out the \"help wanted\" label on github.","title":"Pull Requests"},{"location":"contributing/#development-facilities","text":"To make contributing as easy and fast as possible, you'll want to run tests and linting locally. tl;dr : use make format to fix formatting, make to run tests and linting & make docs to build the docs. You'll need to have python 3.6, 3.7, or 3.8, virtualenv, git, and make installed. Clone your fork and go into the repository directory: git clone git@github.com:<your username>/clinv.git cd clinv Set up the virtualenv for running tests: virtualenv -p ` which python3.7 ` env source env/bin/activate Install clinv, dependencies and configure the pre-commits: make install Checkout a new branch and make your changes: git checkout -b my-new-feature-branch Fix formatting and imports: clinv uses black to enforce formatting and isort to fix imports. make format Run tests and linting: make There are more sub-commands in Makefile like test-code , test-examples , mypy or security which you might want to use, but generally make should be all you need. If you need to pass specific arguments to pytest use the ARGS variable, for example make test ARGs='-k test_markdownlint_passes' . Build documentation: If you have changed the documentation, make sure it builds the static site. Once built it will serve the documentation at localhost:8000 : make docs Commit, push, and create your pull request. Make a new release: To generate the changelog of the new changes, build the package, upload to pypi and clean the build files use make bump . We'd love you to contribute to clinv !","title":"Development facilities"},{"location":"hacking/","text":"Hacking \u00b6 This program is developed with TDD , so if you want to add code, you would most likely should add tests. If you don't know how, say so in the pull request and we'll try to help you. All classes, methods and modules are meant to have docstrings, so please add them.","title":"Hacking"},{"location":"hacking/#hacking","text":"This program is developed with TDD , so if you want to add code, you would most likely should add tests. If you don't know how, say so in the pull request and we'll try to help you. All classes, methods and modules are meant to have docstrings, so please add them.","title":"Hacking"},{"location":"migration.notes/","text":"Migration notes \u00b6 0.5.1 -> 0.6.0 \u00b6 Services without aws resources must have the aws: {} value in the user_data yaml. aws: null will fail.","title":"Migration notes"},{"location":"migration.notes/#migration-notes","text":"","title":"Migration notes"},{"location":"migration.notes/#051-060","text":"Services without aws resources must have the aws: {} value in the user_data yaml. aws: null will fail.","title":"0.5.1 -&gt; 0.6.0"},{"location":"report/","text":"Report creation \u00b6 If you want to see similar reports go to clinv/reports/ . Create the report test class \u00b6 On test/reports/ create your report class from this template. Substitute {{ class_name }} (for example PrintReport ) and {{ module_path }} (for example print ) with your values. from tests.reports import ClinvReportBaseTestClass from clinv.reports. {{ module_path }} import {{ class_name }} import unittest class Test {{ class_name }}( ClinvReportBaseTestClass , unittest . TestCase ): ''' Test the {{ class_name }} implementation. ''' def setUp ( self ): super () . setUp () self . report = {{ class_name }}( self . inventory ) def tearDown ( self ): super () . tearDown () def test_output_method ( self ): self . report . output () self . assertTrue ( False ) Create the report class \u00b6 On clinv/sources/ create your source class from this template. Substitute {{ class_name }} and {{ class_id }} with your values. \"\"\" Module to store the {{ class_name }}. Classes: {{ class_name }}: {{ class_description }} \"\"\" from clinv.reports import ClinvReport class {{ class_name }}( ClinvReport ): \"\"\" {{ class_description }} Parameters: inventory (Inventory): Clinv inventory object. Public methods: output: Print the report to stdout. Public attributes: inv (Inventory): Clinv inventory. \"\"\" def __init__ ( self , inventory ): super () . __init__ ( inventory ) def output ( self , resource_id ): \"\"\" Method to print the report to stdout. Parameters: resource_id (str): regular expression of a resource id. Returns: stdout: Resource information \"\"\"","title":"Report creation"},{"location":"report/#report-creation","text":"If you want to see similar reports go to clinv/reports/ .","title":"Report creation"},{"location":"report/#create-the-report-test-class","text":"On test/reports/ create your report class from this template. Substitute {{ class_name }} (for example PrintReport ) and {{ module_path }} (for example print ) with your values. from tests.reports import ClinvReportBaseTestClass from clinv.reports. {{ module_path }} import {{ class_name }} import unittest class Test {{ class_name }}( ClinvReportBaseTestClass , unittest . TestCase ): ''' Test the {{ class_name }} implementation. ''' def setUp ( self ): super () . setUp () self . report = {{ class_name }}( self . inventory ) def tearDown ( self ): super () . tearDown () def test_output_method ( self ): self . report . output () self . assertTrue ( False )","title":"Create the report test class"},{"location":"report/#create-the-report-class","text":"On clinv/sources/ create your source class from this template. Substitute {{ class_name }} and {{ class_id }} with your values. \"\"\" Module to store the {{ class_name }}. Classes: {{ class_name }}: {{ class_description }} \"\"\" from clinv.reports import ClinvReport class {{ class_name }}( ClinvReport ): \"\"\" {{ class_description }} Parameters: inventory (Inventory): Clinv inventory object. Public methods: output: Print the report to stdout. Public attributes: inv (Inventory): Clinv inventory. \"\"\" def __init__ ( self , inventory ): super () . __init__ ( inventory ) def output ( self , resource_id ): \"\"\" Method to print the report to stdout. Parameters: resource_id (str): regular expression of a resource id. Returns: stdout: Resource information \"\"\"","title":"Create the report class"},{"location":"source/","text":"Source and Resource creation \u00b6 Create a new source \u00b6 A source is an abstraction from where we obtain resources and index them into our inventory. For the purpose of this section, we'll assume that the new source we want to add to our inventory is called newsource . If you want to see similar sources go to clinv/sources/ . Desired Interface \u00b6 To ensure the expected behavior of the sources, the class must follow a common interface. Don't worry if you don't understand yet what does each element mean, you'll discover it as you read the hole document. It must have the following attributes: id (str): ID of the resource. source_data (dict): Aggregated source supplied data. user_data (dict): Aggregated user supplied data. And the following public methods: generate_source_data: Generates the source_data attribute and returns it. generate_user_data: Generates the user_data attribute and returns it. generate_inventory: Generates the inventory dictionary with the source resource. Create the source test class \u00b6 On test/sources/ create your source class from this template. Substitute {{ class_name }} with your value. Also fill up the self.desired_source_data and self.desired_user_data with a representative template of the data you want to store into the inventory. from clinv.sources import {{ class_name }} src from tests.sources import ClinvSourceBaseTestClass import unittest class Test {{ class_name }} Source ( ClinvSourceBaseTestClass , unittest . TestCase ): ''' Test the {{ class_name }} implementation in the inventory. ''' def setUp ( self ): super () . setUp () self . source_obj = {{ class_name }} src # Initialize object to test source_data = {} user_data = {} self . src = self . source_obj ( source_data , user_data ) # What data we want to aggregate to our inventory self . desired_source_data = { } self . desired_user_data = { } self . src . source_data = self . desired_source_data def tearDown ( self ): super () . tearDown () def test_generate_source_data_creates_expected_source_data_attrib ( self ): # Mock here the call to your provider self . src . source_data = {} generated_source_data = self . src . generate_source_data () self . assertEqual ( self . src . source_data , self . desired_source_data , ) self . assertEqual ( generated_source_data , self . desired_source_data , ) @unittest . skip ( 'Not yet' ) def test_generate_user_data_creates_expected_user_data_attrib ( self ): generated_user_data = self . src . generate_user_data () self . assertEqual ( self . src . user_data , self . desired_user_data , ) self . assertEqual ( generated_user_data , self . desired_user_data , ) @unittest . skip ( 'Not yet' ) def test_generate_user_data_doesnt_loose_existing_data ( self ): user_key = [ key for key in self . desired_user_data . keys ()][ 0 ] desired_user_data = { user_key : {}} self . src . user_data = desired_user_data self . src . generate_user_data () self . assertEqual ( self . src . user_data , desired_user_data , ) @unittest . skip ( 'Not yet' ) def test_generate_inventory_return_empty_dict_if_no_data ( self ): self . src . source_data = {} self . assertEqual ( self . src . generate_inventory (), {}) @unittest . skip ( 'Not yet' ) @patch ( 'clinv.sources.{{ module_name }}.{{ class_name }}' ) def test_generate_inventory_creates_expected_dictionary ( self , resource_mock ): resource_id = '{{ resource_id }}' self . src . user_data = self . desired_user_data desired_mock_input = { ** self . src . user_data [ resource_id ], ** self . src . source_data [ resource_id ], } desired_inventory = self . src . generate_inventory () self . assertEqual ( resource_mock . assert_called_with ( { resource_id : desired_mock_input }, ), None , ) self . assertEqual ( desired_inventory , { resource_id : resource_mock . return_value }, ) Create the source class \u00b6 On clinv/sources/ create your source class from this template. Substitute {{ class_name }} and {{ class_id }} with your values. from clinv.sources import ClinvSourcesrc , ClinvGenericResource class {{ class_name }} src ( ClinvSourcesrc ): \"\"\" Class to gather and manipulate the {{ class_name }} resources. Parameters: source_data (dict): {{ class_name }}src compatible source_data dictionary. user_data (dict): {{ class_name }}src compatible user_data dictionary. Public methods: generate_source_data: Generates the source_data attribute and returns it. generate_user_data: Generates the user_data attribute and returns it. generate_inventory: Generates the inventory dictionary with the source resource. Public attributes: id (str): ID of the resource. source_data (dict): Aggregated source supplied data. user_data (dict): Aggregated user supplied data. log (logging object): \"\"\" def __init__ ( self , source_data = {}, user_data = {}): super () . __init__ ( source_data , user_data ) self . id = '{{ class_id }}' def generate_source_data ( self ): \"\"\" Do aggregation of the source data to generate the source dictionary into self.source_data, with the following structure: { } Returns: dict: content of self.source_data. \"\"\" self . log . info ( 'Fetching {{ class_name }} inventory' ) self . source_data = {} return self . source_data def generate_user_data ( self ): \"\"\" Do aggregation of the user data to populate the self.user_data attribute with the user_data.yaml information or with default values. It needs the information of self.source_data, therefore it should be called after generate_source_data. Returns: dict: content of self.user_data. \"\"\" return self . user_data def generate_inventory ( self ): \"\"\" Do aggregation of the user and source data to populate the self.inv attribute with {{ class_name }} resources. It needs the information of self.source_data and self.user_data, therefore it should be called after generate_source_data and generate_user_data. Returns: dict: {{ class_name }} inventory with user and source data \"\"\" inventory = {} for resource_id , resource in self . source_data . items (): # Load the user_data into the source_data record for key , value in self . user_data [ resource_id ] . items (): resource [ key ] = value inventory [ resource_id ] = {{ class_name }}({ resource_id : resource }) return inventory If you need to clean the dictionary created by your provider, use the self.prune_dictionary method. Create the generate_source_data method \u00b6 This method is meant to extract the information from your source, for example AWS and save it into the self.source_data , as well as return it. Create the generate_user_data method \u00b6 This method is meant to extract the information from the user, so it takes the resources saved on self.source_data and generates the basic template for each one and saves them into self.user_data . Create the generate_inventory method \u00b6 This method is meant to initiate the resource object of the source we're adding. This object doesn't exist yet, but we'll do that later. After initializing all the objects they are returned. Add your source to the loaded sources \u00b6 Import it in clinv/inventory.py and add it into the active_source_plugins variable Create the resource class \u00b6 On clinv/sources/ create your source class from this template. Substitute {{ class_name }} and {{ class_id }} with your values. class {{ class_name }}( ClinvGenericResource ): \"\"\" Class to extend the ClinvGenericResource abstract class. It gathers methods and attributes for the {{ class_name }} resources. Public methods: print: Prints information of the resource. Public properties: name: Returns the name of the record. \"\"\" def __init__ ( self , raw_data ): \"\"\" Execute the __init__ of the parent class ClinvActiveResource. \"\"\" super () . __init__ ( raw_data ) Create the resource test class \u00b6 class Test {{ class_name }}( ClinvGenericResourceTests , unittest . TestCase ): def setUp ( self ): self . module_name = '{{ module_name }}' self . id = '{{ class_id }}' super () . setUp () self . raw = { # Example of the dictionary to initialize the object. } self . resource = {{ class_name }}( self . raw ) def tearDown ( self ): super () . tearDown () Think if you can add more search filters in the object search method. Add resource to the reports \u00b6 There are some reports that are generic, such as list or print , but there are some that still aren't. So you'll need to manually add your resource to export and unassigned . Add resource to the cli \u00b6 For the reports that aren't generic add them in clinv/cli.py . Test that everything works \u00b6 Execute the following tasks Generate the new inventory clinv generate . Edit the use_data.yml . Regenerate the inventory and check that no information is lost. Check the different reports. Add documentation \u00b6 Complete the README.md and History.md","title":"Source and Resource creation"},{"location":"source/#source-and-resource-creation","text":"","title":"Source and Resource creation"},{"location":"source/#create-a-new-source","text":"A source is an abstraction from where we obtain resources and index them into our inventory. For the purpose of this section, we'll assume that the new source we want to add to our inventory is called newsource . If you want to see similar sources go to clinv/sources/ .","title":"Create a new source"},{"location":"source/#desired-interface","text":"To ensure the expected behavior of the sources, the class must follow a common interface. Don't worry if you don't understand yet what does each element mean, you'll discover it as you read the hole document. It must have the following attributes: id (str): ID of the resource. source_data (dict): Aggregated source supplied data. user_data (dict): Aggregated user supplied data. And the following public methods: generate_source_data: Generates the source_data attribute and returns it. generate_user_data: Generates the user_data attribute and returns it. generate_inventory: Generates the inventory dictionary with the source resource.","title":"Desired Interface"},{"location":"source/#create-the-source-test-class","text":"On test/sources/ create your source class from this template. Substitute {{ class_name }} with your value. Also fill up the self.desired_source_data and self.desired_user_data with a representative template of the data you want to store into the inventory. from clinv.sources import {{ class_name }} src from tests.sources import ClinvSourceBaseTestClass import unittest class Test {{ class_name }} Source ( ClinvSourceBaseTestClass , unittest . TestCase ): ''' Test the {{ class_name }} implementation in the inventory. ''' def setUp ( self ): super () . setUp () self . source_obj = {{ class_name }} src # Initialize object to test source_data = {} user_data = {} self . src = self . source_obj ( source_data , user_data ) # What data we want to aggregate to our inventory self . desired_source_data = { } self . desired_user_data = { } self . src . source_data = self . desired_source_data def tearDown ( self ): super () . tearDown () def test_generate_source_data_creates_expected_source_data_attrib ( self ): # Mock here the call to your provider self . src . source_data = {} generated_source_data = self . src . generate_source_data () self . assertEqual ( self . src . source_data , self . desired_source_data , ) self . assertEqual ( generated_source_data , self . desired_source_data , ) @unittest . skip ( 'Not yet' ) def test_generate_user_data_creates_expected_user_data_attrib ( self ): generated_user_data = self . src . generate_user_data () self . assertEqual ( self . src . user_data , self . desired_user_data , ) self . assertEqual ( generated_user_data , self . desired_user_data , ) @unittest . skip ( 'Not yet' ) def test_generate_user_data_doesnt_loose_existing_data ( self ): user_key = [ key for key in self . desired_user_data . keys ()][ 0 ] desired_user_data = { user_key : {}} self . src . user_data = desired_user_data self . src . generate_user_data () self . assertEqual ( self . src . user_data , desired_user_data , ) @unittest . skip ( 'Not yet' ) def test_generate_inventory_return_empty_dict_if_no_data ( self ): self . src . source_data = {} self . assertEqual ( self . src . generate_inventory (), {}) @unittest . skip ( 'Not yet' ) @patch ( 'clinv.sources.{{ module_name }}.{{ class_name }}' ) def test_generate_inventory_creates_expected_dictionary ( self , resource_mock ): resource_id = '{{ resource_id }}' self . src . user_data = self . desired_user_data desired_mock_input = { ** self . src . user_data [ resource_id ], ** self . src . source_data [ resource_id ], } desired_inventory = self . src . generate_inventory () self . assertEqual ( resource_mock . assert_called_with ( { resource_id : desired_mock_input }, ), None , ) self . assertEqual ( desired_inventory , { resource_id : resource_mock . return_value }, )","title":"Create the source test class"},{"location":"source/#create-the-source-class","text":"On clinv/sources/ create your source class from this template. Substitute {{ class_name }} and {{ class_id }} with your values. from clinv.sources import ClinvSourcesrc , ClinvGenericResource class {{ class_name }} src ( ClinvSourcesrc ): \"\"\" Class to gather and manipulate the {{ class_name }} resources. Parameters: source_data (dict): {{ class_name }}src compatible source_data dictionary. user_data (dict): {{ class_name }}src compatible user_data dictionary. Public methods: generate_source_data: Generates the source_data attribute and returns it. generate_user_data: Generates the user_data attribute and returns it. generate_inventory: Generates the inventory dictionary with the source resource. Public attributes: id (str): ID of the resource. source_data (dict): Aggregated source supplied data. user_data (dict): Aggregated user supplied data. log (logging object): \"\"\" def __init__ ( self , source_data = {}, user_data = {}): super () . __init__ ( source_data , user_data ) self . id = '{{ class_id }}' def generate_source_data ( self ): \"\"\" Do aggregation of the source data to generate the source dictionary into self.source_data, with the following structure: { } Returns: dict: content of self.source_data. \"\"\" self . log . info ( 'Fetching {{ class_name }} inventory' ) self . source_data = {} return self . source_data def generate_user_data ( self ): \"\"\" Do aggregation of the user data to populate the self.user_data attribute with the user_data.yaml information or with default values. It needs the information of self.source_data, therefore it should be called after generate_source_data. Returns: dict: content of self.user_data. \"\"\" return self . user_data def generate_inventory ( self ): \"\"\" Do aggregation of the user and source data to populate the self.inv attribute with {{ class_name }} resources. It needs the information of self.source_data and self.user_data, therefore it should be called after generate_source_data and generate_user_data. Returns: dict: {{ class_name }} inventory with user and source data \"\"\" inventory = {} for resource_id , resource in self . source_data . items (): # Load the user_data into the source_data record for key , value in self . user_data [ resource_id ] . items (): resource [ key ] = value inventory [ resource_id ] = {{ class_name }}({ resource_id : resource }) return inventory If you need to clean the dictionary created by your provider, use the self.prune_dictionary method.","title":"Create the source class"},{"location":"source/#create-the-generate_source_data-method","text":"This method is meant to extract the information from your source, for example AWS and save it into the self.source_data , as well as return it.","title":"Create the generate_source_data method"},{"location":"source/#create-the-generate_user_data-method","text":"This method is meant to extract the information from the user, so it takes the resources saved on self.source_data and generates the basic template for each one and saves them into self.user_data .","title":"Create the generate_user_data method"},{"location":"source/#create-the-generate_inventory-method","text":"This method is meant to initiate the resource object of the source we're adding. This object doesn't exist yet, but we'll do that later. After initializing all the objects they are returned.","title":"Create the generate_inventory method"},{"location":"source/#add-your-source-to-the-loaded-sources","text":"Import it in clinv/inventory.py and add it into the active_source_plugins variable","title":"Add your source to the loaded sources"},{"location":"source/#create-the-resource-class","text":"On clinv/sources/ create your source class from this template. Substitute {{ class_name }} and {{ class_id }} with your values. class {{ class_name }}( ClinvGenericResource ): \"\"\" Class to extend the ClinvGenericResource abstract class. It gathers methods and attributes for the {{ class_name }} resources. Public methods: print: Prints information of the resource. Public properties: name: Returns the name of the record. \"\"\" def __init__ ( self , raw_data ): \"\"\" Execute the __init__ of the parent class ClinvActiveResource. \"\"\" super () . __init__ ( raw_data )","title":"Create the resource class"},{"location":"source/#create-the-resource-test-class","text":"class Test {{ class_name }}( ClinvGenericResourceTests , unittest . TestCase ): def setUp ( self ): self . module_name = '{{ module_name }}' self . id = '{{ class_id }}' super () . setUp () self . raw = { # Example of the dictionary to initialize the object. } self . resource = {{ class_name }}( self . raw ) def tearDown ( self ): super () . tearDown () Think if you can add more search filters in the object search method.","title":"Create the resource test class"},{"location":"source/#add-resource-to-the-reports","text":"There are some reports that are generic, such as list or print , but there are some that still aren't. So you'll need to manually add your resource to export and unassigned .","title":"Add resource to the reports"},{"location":"source/#add-resource-to-the-cli","text":"For the reports that aren't generic add them in clinv/cli.py .","title":"Add resource to the cli"},{"location":"source/#test-that-everything-works","text":"Execute the following tasks Generate the new inventory clinv generate . Edit the use_data.yml . Regenerate the inventory and check that no information is lost. Check the different reports.","title":"Test that everything works"},{"location":"source/#add-documentation","text":"Complete the README.md and History.md","title":"Add documentation"},{"location":"todo/","text":"Todo \u00b6 HH \u00b6 H \u00b6 Add clinv verify to test: No user has changed it's policies attached No group has changed it's policies attached The group members are the ones that we desired Check if 2fa is enabled for users with password the access keys are updated Add IAM policy, roles and instance profiles support Add comments to ec2 instances, projects, services and informations M \u00b6 Add risk management support Autoscaling group support Add to clinv verify to check if there are deleted or terminated aws resources assigned to projects. Create an input method clinv create service Create an edit method clinv edit ser_01 Refactor the Source tests into a parent testcase to avoid duplicated code Service object access part divided by user type with each it's type of access and information it access Add related subcommand to get what resources are associated with a defined resource (with the optional -n flag to specify the levels of association) Improve service search so if the children resources match, the service matches. Search also into the terminated resources with a specific flag. But by default don't search on terminated (add a if self.state == terminated return False on ClinvGenericResource.search()). (refactor from list services) Read the description from the AWS resources L \u00b6 Automatic alphabetic reindex of informations, services and projects when c generate Terminated report that shows the resources of terminated services, to check if they should be destroyed Create the --json flag for reports","title":"Todo"},{"location":"todo/#todo","text":"","title":"Todo"},{"location":"todo/#hh","text":"","title":"HH"},{"location":"todo/#h","text":"Add clinv verify to test: No user has changed it's policies attached No group has changed it's policies attached The group members are the ones that we desired Check if 2fa is enabled for users with password the access keys are updated Add IAM policy, roles and instance profiles support Add comments to ec2 instances, projects, services and informations","title":"H"},{"location":"todo/#m","text":"Add risk management support Autoscaling group support Add to clinv verify to check if there are deleted or terminated aws resources assigned to projects. Create an input method clinv create service Create an edit method clinv edit ser_01 Refactor the Source tests into a parent testcase to avoid duplicated code Service object access part divided by user type with each it's type of access and information it access Add related subcommand to get what resources are associated with a defined resource (with the optional -n flag to specify the levels of association) Improve service search so if the children resources match, the service matches. Search also into the terminated resources with a specific flag. But by default don't search on terminated (add a if self.state == terminated return False on ClinvGenericResource.search()). (refactor from list services) Read the description from the AWS resources","title":"M"},{"location":"todo/#l","text":"Automatic alphabetic reindex of informations, services and projects when c generate Terminated report that shows the resources of terminated services, to check if they should be destroyed Create the --json flag for reports","title":"L"},{"location":"adr/001-refactor_to_domain_driven_design/","text":"Status \u00b6 Accepted Context \u00b6 The codebase of the project has grown old pretty fast, there are the next problems: The code structure doesn't comply with the domain driven design structure I'm using with the rest of my projects, that means that maintaining it is uncomfortable for me. I can't use the cookiecutter template to adapt the improvements I do on other projects. There is a high coupling between an adapter (aws) and the storage solution. I'm using argparse instead of click to define the cli A lot of the testing is done using mocks, instead of having a pyramid of unit and e2e tests. The model and service functionality is all mixed up in the models. The performance is bad when you have many resources. Proposals \u00b6 Refactor the code to use the domain driven design structure. Make it compliant with the cookiecutter python template . Migrate cli definition to click. Add type hints Decision \u00b6 Implement the only proposal Consequences \u00b6","title":"Status"},{"location":"adr/001-refactor_to_domain_driven_design/#status","text":"Accepted","title":"Status"},{"location":"adr/001-refactor_to_domain_driven_design/#context","text":"The codebase of the project has grown old pretty fast, there are the next problems: The code structure doesn't comply with the domain driven design structure I'm using with the rest of my projects, that means that maintaining it is uncomfortable for me. I can't use the cookiecutter template to adapt the improvements I do on other projects. There is a high coupling between an adapter (aws) and the storage solution. I'm using argparse instead of click to define the cli A lot of the testing is done using mocks, instead of having a pyramid of unit and e2e tests. The model and service functionality is all mixed up in the models. The performance is bad when you have many resources.","title":"Context"},{"location":"adr/001-refactor_to_domain_driven_design/#proposals","text":"Refactor the code to use the domain driven design structure. Make it compliant with the cookiecutter python template . Migrate cli definition to click. Add type hints","title":"Proposals"},{"location":"adr/001-refactor_to_domain_driven_design/#decision","text":"Implement the only proposal","title":"Decision"},{"location":"adr/001-refactor_to_domain_driven_design/#consequences","text":"","title":"Consequences"},{"location":"adr/adr/","text":"ADR are short text documents that captures an important architectural decision made along with its context and consequences.","title":"Adr"}]}