{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DevSecOps command line asset inventory Installing \u00b6 pip install clinv Work in progress Lately I've completely rewritten clinv, I'll update the docs as soon as possible. References \u00b6 As most open sourced programs, clinv is standing on the shoulders of giants, namely: Pytest Testing framework, enhanced by the awesome pytest-cases library that made the parametrization of the tests a lovely experience. Mypy Python static type checker. Flakehell Python linter with lots of checks . Black Python formatter to keep a nice style without effort. Autoimport Python formatter to automatically fix wrong import statements. isort Python formatter to order the import statements. Pip-tools Command line tool to manage the dependencies. Mkdocs To build this documentation site, with the Material theme . Safety To check the installed dependencies for known security vulnerabilities. Bandit To finds common security issues in Python code. Yamlfix YAML fixer. Contributing \u00b6 For guidance on setting up a development environment, and how to make a contribution to clinv , see Contributing to clinv .","title":"Clinv"},{"location":"#installing","text":"pip install clinv Work in progress Lately I've completely rewritten clinv, I'll update the docs as soon as possible.","title":"Installing"},{"location":"#references","text":"As most open sourced programs, clinv is standing on the shoulders of giants, namely: Pytest Testing framework, enhanced by the awesome pytest-cases library that made the parametrization of the tests a lovely experience. Mypy Python static type checker. Flakehell Python linter with lots of checks . Black Python formatter to keep a nice style without effort. Autoimport Python formatter to automatically fix wrong import statements. isort Python formatter to order the import statements. Pip-tools Command line tool to manage the dependencies. Mkdocs To build this documentation site, with the Material theme . Safety To check the installed dependencies for known security vulnerabilities. Bandit To finds common security issues in Python code. Yamlfix YAML fixer.","title":"References"},{"location":"#contributing","text":"For guidance on setting up a development environment, and how to make a contribution to clinv , see Contributing to clinv .","title":"Contributing"},{"location":"contributing/","text":"So you've started using clinv and want to show your gratitude to the project, depending on your programming skills there are different ways to do so. I don't know how to program \u00b6 There are several ways you can contribute: Open an issue if you encounter any bug or to let us know if you want a new feature to be implemented. Spread the word about the program. Review the documentation and try to improve it. I know how to program in Python \u00b6 If you have some python knowledge there are some additional ways to contribute. We've ordered the issues in milestones , check the issues in the smaller one, as it's where we'll be spending most of our efforts. Try the good first issues , as they are expected to be easier to get into the project. We develop the program with TDD , so we expect any contribution to have it's associated tests. We also try to maintain an updated documentation of the project, so think if your contribution needs to update it. We know that the expected code quality is above average. Therefore it might be changeling to get the initial grasp of the project structure, know how to make the tests, update the documentation or use all the project technology stack. but please don't let this fact discourage you from contributing: If you want to develop a new feature, explain how you'd like to do it in the related issue. If you don't know how to test your code, do the pull request without the tests and we'll try to do them for you. Issues \u00b6 Questions, feature requests and bug reports are all welcome as issues. To report a security vulnerability, please see our security policy instead. To make it as simple as possible for us to help you, please include the output of the following call in your issue: python -c \"import clinv.version; print(clinv.version.version_info())\" or if you have make installed, you can use make version . Please try to always include the above unless you're unable to install clinv or know it's not relevant to your question or feature request. Pull Requests \u00b6 clinv is released regularly so you should see your improvements release in a matter of days or weeks. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. If you're looking for something to get your teeth into, check out the \"help wanted\" label on github. Development facilities \u00b6 To make contributing as easy and fast as possible, you'll want to run tests and linting locally. tl;dr : use make format to fix formatting, make to run tests and linting & make docs to build the docs. You'll need to have python 3.6, 3.7, or 3.8, virtualenv, git, and make installed. Clone your fork and go into the repository directory: git clone git@github.com:<your username>/clinv.git cd clinv Set up the virtualenv for running tests: virtualenv -p ` which python3.7 ` env source env/bin/activate Install clinv, dependencies and configure the pre-commits: make install Checkout a new branch and make your changes: git checkout -b my-new-feature-branch Fix formatting and imports: clinv uses black to enforce formatting and isort to fix imports. make format Run tests and linting: make There are more sub-commands in Makefile like test-code , test-examples , mypy or security which you might want to use, but generally make should be all you need. If you need to pass specific arguments to pytest use the ARGS variable, for example make test ARGs='-k test_markdownlint_passes' . Build documentation: If you have changed the documentation, make sure it builds the static site. Once built it will serve the documentation at localhost:8000 : make docs Commit, push, and create your pull request. Make a new release: To generate the changelog of the new changes, build the package, upload to pypi and clean the build files use make bump . We'd love you to contribute to clinv !","title":"Contributing"},{"location":"contributing/#i-dont-know-how-to-program","text":"There are several ways you can contribute: Open an issue if you encounter any bug or to let us know if you want a new feature to be implemented. Spread the word about the program. Review the documentation and try to improve it.","title":"I don't know how to program"},{"location":"contributing/#i-know-how-to-program-in-python","text":"If you have some python knowledge there are some additional ways to contribute. We've ordered the issues in milestones , check the issues in the smaller one, as it's where we'll be spending most of our efforts. Try the good first issues , as they are expected to be easier to get into the project. We develop the program with TDD , so we expect any contribution to have it's associated tests. We also try to maintain an updated documentation of the project, so think if your contribution needs to update it. We know that the expected code quality is above average. Therefore it might be changeling to get the initial grasp of the project structure, know how to make the tests, update the documentation or use all the project technology stack. but please don't let this fact discourage you from contributing: If you want to develop a new feature, explain how you'd like to do it in the related issue. If you don't know how to test your code, do the pull request without the tests and we'll try to do them for you.","title":"I know how to program in Python"},{"location":"contributing/#issues","text":"Questions, feature requests and bug reports are all welcome as issues. To report a security vulnerability, please see our security policy instead. To make it as simple as possible for us to help you, please include the output of the following call in your issue: python -c \"import clinv.version; print(clinv.version.version_info())\" or if you have make installed, you can use make version . Please try to always include the above unless you're unable to install clinv or know it's not relevant to your question or feature request.","title":"Issues"},{"location":"contributing/#pull-requests","text":"clinv is released regularly so you should see your improvements release in a matter of days or weeks. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. If you're looking for something to get your teeth into, check out the \"help wanted\" label on github.","title":"Pull Requests"},{"location":"contributing/#development-facilities","text":"To make contributing as easy and fast as possible, you'll want to run tests and linting locally. tl;dr : use make format to fix formatting, make to run tests and linting & make docs to build the docs. You'll need to have python 3.6, 3.7, or 3.8, virtualenv, git, and make installed. Clone your fork and go into the repository directory: git clone git@github.com:<your username>/clinv.git cd clinv Set up the virtualenv for running tests: virtualenv -p ` which python3.7 ` env source env/bin/activate Install clinv, dependencies and configure the pre-commits: make install Checkout a new branch and make your changes: git checkout -b my-new-feature-branch Fix formatting and imports: clinv uses black to enforce formatting and isort to fix imports. make format Run tests and linting: make There are more sub-commands in Makefile like test-code , test-examples , mypy or security which you might want to use, but generally make should be all you need. If you need to pass specific arguments to pytest use the ARGS variable, for example make test ARGs='-k test_markdownlint_passes' . Build documentation: If you have changed the documentation, make sure it builds the static site. Once built it will serve the documentation at localhost:8000 : make docs Commit, push, and create your pull request. Make a new release: To generate the changelog of the new changes, build the package, upload to pypi and clean the build files use make bump . We'd love you to contribute to clinv !","title":"Development facilities"},{"location":"hacking/","text":"Hacking \u00b6 This program is developed with TDD , so if you want to add code, you would most likely should add tests. If you don't know how, say so in the pull request and we'll try to help you. All classes, methods and modules are meant to have docstrings, so please add them.","title":"Hacking"},{"location":"hacking/#hacking","text":"This program is developed with TDD , so if you want to add code, you would most likely should add tests. If you don't know how, say so in the pull request and we'll try to help you. All classes, methods and modules are meant to have docstrings, so please add them.","title":"Hacking"},{"location":"migration.notes/","text":"Migration notes \u00b6 0.5.1 -> 0.6.0 \u00b6 Services without aws resources must have the aws: {} value in the user_data yaml. aws: null will fail.","title":"Migration notes"},{"location":"migration.notes/#migration-notes","text":"","title":"Migration notes"},{"location":"migration.notes/#051-060","text":"Services without aws resources must have the aws: {} value in the user_data yaml. aws: null will fail.","title":"0.5.1 -&gt; 0.6.0"},{"location":"reference/","text":"clinv special \u00b6 Define the package importable objects. adapters special \u00b6 Store the exposed adapters. abstract \u00b6 Define the interface for the source adapters. AbstractSource \u00b6 Define common methods and define the interface of the source adapters. update ( self , resource_types = None , active_resources = None ) \u00b6 Get the latest state of the source entities. Parameters: Name Type Description Default resource_types Optional[List[str]] Limit the update to these type of resources. None active_resources Optional[List[~EntityType]] List of active resources in the repository. None Returns: Type Description List[clinv.model.entity.EntityUpdate] List of entity updates. Source code in clinv/adapters/abstract.py @abc . abstractmethod def update ( self , resource_types : Optional [ List [ str ]] = None , active_resources : Optional [ List [ EntityType ]] = None , ) -> List [ EntityUpdate ]: \"\"\"Get the latest state of the source entities. Args: resource_types: Limit the update to these type of resources. active_resources: List of active resources in the repository. Returns: List of entity updates. \"\"\" raise NotImplementedError aws \u00b6 Define the AWS sources used by Clinv. AWSSource \u00b6 Define the interface to interact with the source of AWS entities. regions : List [ str ] property readonly \u00b6 Get the AWS regions. Returns: Type Description List[str] update ( self , resource_types = None , active_resources = None ) \u00b6 Get the latest state of the source entities. Parameters: Name Type Description Default resource_types Optional[List[str]] Limit the update to these type of resources. None active_resources Optional[List[~EntityType]] List of active resources in the repository. None Returns: Type Description List[clinv.model.entity.EntityUpdate] List of entity updates. Source code in clinv/adapters/aws.py def update ( self , resource_types : Optional [ List [ str ]] = None , active_resources : Optional [ List [ EntityType ]] = None , ) -> List [ EntityUpdate ]: \"\"\"Get the latest state of the source entities. Args: resource_types: Limit the update to these type of resources. active_resources: List of active resources in the repository. Returns: List of entity updates. \"\"\" log . info ( \"Updating AWS entities.\" ) update_mapper = { \"asg\" : self . _update_asg , \"ec2\" : self . _update_ec2 , \"iamg\" : self . _update_iam_groups , \"iamu\" : self . _update_iam_users , \"s3\" : self . _update_s3 , \"sg\" : self . _update_sg , \"rds\" : self . _update_rds , \"r53\" : self . _update_route53 , \"vpc\" : self . _update_vpc , } if resource_types is None : resource_types = list ( update_mapper . keys ()) else : # Only process the AWS resources resource_types = [ resource_type for resource_type in resource_types if resource_type in update_mapper ] entity_updates = [] if active_resources is None : remaining_entities = [] else : remaining_entities = active_resources # Create entity updates for resource_type in track ( resource_types , description = \"Get AWS data\" ): with suppress ( KeyError ): entity_updates += update_mapper [ resource_type ]( remaining_entities ) # Mark entities that were no present in the updates as terminated resource_models = [ RESOURCE_TYPES [ resource_type ] for resource_type in resource_types ] for entity in remaining_entities : if type ( entity ) in resource_models : log . info ( f \"Marking ' { entity . _model_name } ' with id ' { entity . id_ } ' and name \" f \"' { entity . name } ' as terminated\" ) entity . state = EntityState . TERMINATED entity_updates . append ( EntityUpdate ( model = type ( entity ), data = entity . dict ()) ) return entity_updates build_security_group_rule_data ( rule_data ) \u00b6 Adapt the security group rule from the AWS format to the SecurityGroupRule. Parameters: Name Type Description Default rule_data Dict[str, Any] dictionary of the security group data. required Returns: Type Description Dict[str, Any] dictionary compatible with the SecurityGroupRule fields. Source code in clinv/adapters/aws.py def build_security_group_rule_data ( rule_data : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\"Adapt the security group rule from the AWS format to the SecurityGroupRule. Args: rule_data: dictionary of the security group data. Returns: dictionary compatible with the SecurityGroupRule fields. \"\"\" rule = { \"protocol\" : rule_data [ \"IpProtocol\" ] . upper (), \"ip_range\" : [], \"ipv6_range\" : [], \"sg_range\" : [], } if rule [ \"protocol\" ] == \"ICMP\" : rule [ \"ports\" ] = [ - 2 ] elif rule [ \"protocol\" ] == \"-1\" : rule [ \"protocol\" ] = \"TCP & UDP & ICMP\" rule [ \"ports\" ] = [ - 1 ] else : rule [ \"ports\" ] = list ( range ( rule_data [ \"FromPort\" ], rule_data [ \"ToPort\" ] + 1 )) with suppress ( KeyError ): rule [ \"ip_range\" ] = [ cidr [ \"CidrIp\" ] for cidr in rule_data [ \"IpRanges\" ]] with suppress ( KeyError ): rule [ \"ipv6_range\" ] = [ cidr [ \"CidrIp\" ] for cidr in rule_data [ \"Ipv6Ranges\" ]] with suppress ( KeyError ): rule [ \"sg_range\" ] = [ sg [ \"GroupId\" ] for sg in rule_data [ \"UserIdGroupPairs\" ]] # The description of the security group rules is attached to each of the # elements of the lists. for description_place in [ \"IpRanges\" , \"Ipv6Ranges\" , \"UserIdGroupPairs\" ]: with suppress ( KeyError , IndexError ): rule [ \"description\" ] = [ cidr [ \"Description\" ] for cidr in rule_data [ description_place ] ][ 0 ] break return rule fake \u00b6 Define the fake adapters used for testing. FakeSource \u00b6 Define Fake source to be used in the edge to edge tests. __init__ ( self ) special \u00b6 Initialize the source attributes. Parameters: Name Type Description Default supported_models List of models supported by the source. required Source code in clinv/adapters/fake.py def __init__ ( self ) -> None : \"\"\"Initialize the source attributes. Args: supported_models: List of models supported by the source. \"\"\" self . supported_models : List [ str ] = [ \"Entity\" ] self . _entity_updates : List [ EntityUpdate ] = [] add_change ( self , entity , entity_data ) \u00b6 Record changes on entities to be returned when calling the update method. Parameters: Name Type Description Default entity_data Dict[str, Any] dictionary with key value to update. required Source code in clinv/adapters/fake.py def add_change ( self , entity : EntityType , entity_data : Dict [ str , Any ]) -> None : \"\"\"Record changes on entities to be returned when calling the update method. Args: entity_data: dictionary with key value to update. \"\"\" entity_data [ \"id_\" ] = entity . id_ entity_data [ \"model\" ] = type ( entity ) self . _entity_updates . append ( EntityUpdate ( data = { ** entity . dict (), ** entity_data })) update ( self , resource_types = None , active_resources = None ) \u00b6 Get the latest state of the source entities. Parameters: Name Type Description Default resource_types Optional[List[str]] Limit the update to these type of resources. None active_resources Optional[List[~EntityType]] List of active resources in the repository. None Returns: Type Description List[clinv.model.entity.EntityUpdate] List of entity updates. Source code in clinv/adapters/fake.py def update ( self , resource_types : Optional [ List [ str ]] = None , active_resources : Optional [ List [ EntityType ]] = None , ) -> List [ EntityUpdate ]: \"\"\"Get the latest state of the source entities. Args: resource_types: Limit the update to these type of resources. active_resources: List of active resources in the repository. Returns: List of entity updates. \"\"\" return self . _entity_updates risk \u00b6 Define the Risk management sources used by Clinv. RiskSource \u00b6 Define the interface to interact with the source of Risk Management entities. update ( self , resource_types = None , active_resources = None ) \u00b6 Get the latest state of the source entities. Parameters: Name Type Description Default resource_types Optional[List[str]] Limit the update to these type of resources. None active_resources Optional[List[~EntityType]] List of active resources in the repository. None Returns: Type Description List[clinv.model.entity.EntityUpdate] List of entity updates. Source code in clinv/adapters/risk.py def update ( self , resource_types : Optional [ List [ str ]] = None , active_resources : Optional [ List [ EntityType ]] = None , ) -> List [ EntityUpdate ]: \"\"\"Get the latest state of the source entities. Args: resource_types: Limit the update to these type of resources. active_resources: List of active resources in the repository. Returns: List of entity updates. \"\"\" log . debug ( \"Updating Risk Management entities.\" ) return [] config \u00b6 Define the configuration of the main program. Config \u00b6 Expose the configuration in a friendly way. Public methods: get: Fetch the configuration value of the specified key. load: Load the configuration from the configuration YAML file. save: Saves the configuration in the configuration YAML file. Attributes and properties: config_path (str): Path to the configuration file. data(dict): Program configuration. __init__ ( self , config_path = '~/.local/share/clinv/config.yaml' ) special \u00b6 Configure the attributes and load the configuration. Source code in clinv/config.py def __init__ ( self , config_path : str = \"~/.local/share/clinv/config.yaml\" ) -> None : \"\"\"Configure the attributes and load the configuration.\"\"\" super () . __init__ () self . config_path = os . path . expanduser ( config_path ) self . load () get ( self , key , default = None ) \u00b6 Fetch the configuration value of the specified key. If there are nested dictionaries, a dot notation can be used. So if the configuration contents are: self.data = { 'first': { 'second': 'value' }, } self.data.get('first.second') == 'value' Source code in clinv/config.py def get ( self , key : str , default : Any = None ) -> Union [ str , int , Dict [ str , Any ], List [ Any ]]: \"\"\"Fetch the configuration value of the specified key. If there are nested dictionaries, a dot notation can be used. So if the configuration contents are: self.data = { 'first': { 'second': 'value' }, } self.data.get('first.second') == 'value' \"\"\" original_key = key config_keys = key . split ( \".\" ) value = self . data . copy () for config_key in config_keys : try : value = value [ config_key ] except KeyError as error : if default is not None : return default raise ConfigError ( f \"Failed to fetch the configuration { config_key } \" f \"when searching for { original_key } \" ) from error return value load ( self ) \u00b6 Load the configuration from the configuration YAML file. Source code in clinv/config.py def load ( self ) -> None : \"\"\"Load the configuration from the configuration YAML file.\"\"\" try : with open ( os . path . expanduser ( self . config_path ), \"r\" ) as file_cursor : try : self . data = YAML () . load ( file_cursor ) except ( ParserError , ScannerError ) as error : raise ConfigError ( str ( error )) from error except FileNotFoundError as error : raise ConfigError ( f \"The configuration file { self . config_path } could not be found.\" ) from error save ( self ) \u00b6 Save the configuration in the configuration YAML file. Source code in clinv/config.py def save ( self ) -> None : \"\"\"Save the configuration in the configuration YAML file.\"\"\" with open ( os . path . expanduser ( self . config_path ), \"w+\" ) as file_cursor : yaml = YAML () yaml . default_flow_style = False yaml . dump ( self . data , file_cursor ) set ( self , key , value ) \u00b6 Set the configuration value of the specified key. If there are nested dictionaries, a dot notation can be used. So if you want to set the configuration: self.data = { 'first': { 'second': 'value' }, } self.data.set('first.second', 'value') Source code in clinv/config.py def set ( self , key : str , value : Union [ str , int ]) -> None : \"\"\"Set the configuration value of the specified key. If there are nested dictionaries, a dot notation can be used. So if you want to set the configuration: self.data = { 'first': { 'second': 'value' }, } self.data.set('first.second', 'value') \"\"\" config_keys : List [ str ] = key . split ( \".\" ) last_key = config_keys . pop ( - 1 ) # Initialize the dictionary structure parent = self . data for config_key in config_keys : try : parent = parent [ config_key ] except KeyError : parent [ config_key ] = {} parent = parent [ config_key ] # Set value parent [ last_key ] = value ConfigError \u00b6 Catch configuration errors. entrypoints special \u00b6 Define the different ways to expose the program functionality. Functions load_logger: Configure the Logging logger. load_adapters ( config ) \u00b6 Configure the source adapters. Parameters: Name Type Description Default config Config program configuration object. required Returns: Type Description List[~AdapterSource] List of configured sources adapters to work with. Source code in clinv/entrypoints/__init__.py def load_adapters ( config : Config ) -> List [ AdapterSource ]: \"\"\"Configure the source adapters. Args: config: program configuration object. Returns: List of configured sources adapters to work with. \"\"\" sources : List [ AdapterSource ] = [] log . debug ( \"Initializing the adapters\" ) for source_name in config [ \"sources\" ]: # ignore. AdapterSource is not callable. I still don't know how to fix this. sources . append ( AVAILABLE_SOURCES [ source_name ]()) # type: ignore return sources load_config ( config_path ) \u00b6 Load the configuration from the file. Source code in clinv/entrypoints/__init__.py def load_config ( config_path : str ) -> Config : \"\"\"Load the configuration from the file.\"\"\" log . debug ( f \"Loading the configuration from file { config_path } \" ) try : config = Config ( config_path ) except ConfigError as error : log . error ( f \"Error parsing yaml of configuration file { config_path } : { str ( error ) } \" ) sys . exit ( 1 ) return config load_logger ( verbose = False ) \u00b6 Configure the Logging logger. Parameters: Name Type Description Default verbose bool Set the logging level to Debug. False Source code in clinv/entrypoints/__init__.py def load_logger ( verbose : bool = False ) -> None : # pragma: no cover \"\"\"Configure the Logging logger. Args: verbose: Set the logging level to Debug. \"\"\" logging . getLogger ( \"boto3\" ) . setLevel ( logging . WARNING ) logging . getLogger ( \"botocore\" ) . setLevel ( logging . WARNING ) if verbose : logging . basicConfig ( stream = sys . stderr , level = logging . DEBUG , format = \" %(message)s \" ) else : logging . basicConfig ( level = logging . INFO , format = \" %(message)s \" , datefmt = \"[ %X ]\" , handlers = [ RichHandler ( rich_tracebacks = True )], ) cli \u00b6 Command line interface definition. model special \u00b6 Module to store the common business model of all entities. aws \u00b6 Define the models of the AWS resources. ASG pydantic-model \u00b6 Represent an AWS ASG. Parameters: Name Type Description Default description required environment Logical environment (production, staging). required id_ unique identifier of the entity. required monitor If the instance is being monitored required name required region AWS region where the instance lives. For example us-east-1 required state required min_size required max_size required desired_size required launch_configuration required launch_template required availability_zones required instances List of instance ids of the autoscaling group required healthcheck if the healthcheck is of type EC2 or ELB required AWSEntity pydantic-model \u00b6 Represent a generic AWS resource. Parameters: Name Type Description Default start_date required monitor If the instance is being monitored required environment Logical environment (production, staging) required EC2 pydantic-model \u00b6 Represent an Elastic Compute Cloud AWS instance. Parameters: Name Type Description Default ami AMI base image. required description required environment Logical environment (production, staging) required id_ unique identifier of the entity. required monitor If the instance is being monitored required name required private_ips required public_ips required security_groups List of security groups id's attached to the instance. required region AWS region where the instance lives. For example us-east-1 required size Instance type. required start_date required state required subnet required vpc required IAMGroup pydantic-model \u00b6 Represent an IAM user. Parameters: Name Type Description Default arn AWS ARN identifier of the resource. required users list of users ids. required IAMUser pydantic-model \u00b6 Represent an IAM user. Parameters: Name Type Description Default arn AWS ARN identifier of the resource. required NetworkProtocol \u00b6 Set the possible network protocols. RDS pydantic-model \u00b6 Represent an AWS RDS database. Parameters: Name Type Description Default description required engine Database type and version. required endpoint Endpoint to connect to the database required environment Logical environment (production, staging) required id_ unique identifier of the entity. required monitor If the instance is being monitored required name required security_groups List of security groups id's attached to the instance. required region AWS region where the instance lives. For example us-east-1 required size Instance type. required start_date required state required subnets required vpc required Route53 pydantic-model \u00b6 Represent an AWS Route53 record. Parameters: Name Type Description Default description required environment Logical environment (production, staging) required id_ unique identifier of the entity. required monitor If the instance is being monitored required name required state required hosted_zone AWS HostedZone containing the record. required value Where does the record point to, or the information it holds. required type_ Record type. Such as A or CNAME . required public If the record is accessed by the general public. required S3 pydantic-model \u00b6 Represent an AWS S3 bucket. Parameters: Name Type Description Default description required public_read If anyone has public read permissions on the bucket. required public_write If anyone has public write permissions on the bucket. required environment Logical environment (production, staging) required id_ unique identifier of the entity. required monitor If the instance is being monitored required name required start_date required state required SecurityGroup pydantic-model \u00b6 Represent an AWS Security Group. Parameters: Name Type Description Default description required environment Logical environment (production, staging). required id_ unique identifier of the entity. required monitor If the instance is being monitored required name required region AWS region where the instance lives. For example us-east-1 required state required SecurityGroupRule pydantic-model \u00b6 Represent an AWS Security Group Rule. Parameters: Name Type Description Default protocol required ports List of ports to open. To model the special cases we use negative ints: * All ports: -1 * Not applicable: -2. For example for ICMP. required ip_range List of ips that are related to the rule. required ipv6_range List of ips of version 6 that are related to the rule. required sg_range List of security group ids that are related to the rule. required VPC pydantic-model \u00b6 Represent an AWS VPC. Parameters: Name Type Description Default description required environment Logical environment (production, staging) required id_ unique identifier of the entity. required monitor If the instance is being monitored required cidr required name required region AWS region where the instance lives. For example us-east-1 required state required entity \u00b6 Define the basic entity. Entity pydantic-model \u00b6 Define the generic clinv entity. Parameters: Name Type Description Default id_ unique identifier of the entity. required name required state required description required EntityState \u00b6 Set the possible entity states. EntityUpdate pydantic-model \u00b6 Define the updates of an entity. set_id_and_model ( values ) classmethod \u00b6 Set the id_ and model attributes. Source code in clinv/model/entity.py @root_validator ( pre = True ) @classmethod def set_id_and_model ( cls , values : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\"Set the id_ and model attributes.\"\"\" values [ \"id_\" ] = values [ \"data\" ][ \"id_\" ] with suppress ( KeyError ): values [ \"model\" ] = values [ \"data\" ] . pop ( \"model\" ) return values Environment \u00b6 Set the possible logical environments. risk \u00b6 Define the Risk management entities. Information pydantic-model \u00b6 Represent the data used by a service or project. Parameters: Name Type Description Default id_ unique identifier of the entity. required name required state required description required personal_data Whether the information contains personal data in terms of RGPD. required responsible Person who is legally responsible of the entity. required People pydantic-model \u00b6 Represent the people of the team. Parameters: Name Type Description Default id_ unique identifier of the entity. required name required state required description required iam_user required email required Project pydantic-model \u00b6 Represent the reason for a group of service and information. Parameters: Name Type Description Default id_ unique identifier of the entity. required name required state required description required aliases Alternative names of the project. required services Service ids used by the project. required informations Information ids used by the project. required people People ids that work on the project. required responsible Person who is legally responsible of the entity. required Service pydantic-model \u00b6 Represent aggregation of IT resources to present an utility to users. Parameters: Name Type Description Default id_ unique identifier of the entity. required name required state required description required authentication List of authentication methods required to access the service. required environment Logical environment (production, staging) required access Level of exposition of the resource. required responsible Person who is legally responsible of the entity. required informations Information ids used by the project. required ServiceAccess \u00b6 Represent possible states of the service access. services \u00b6 Gather all the orchestration functionality required by the program to work. Classes and functions that connect the different domain model objects with the adapters and handlers to achieve the program's purpose. list_entities ( repo , resource_types = None , all_ = False , inactive = False ) \u00b6 List the resources of the repository. Parameters: Name Type Description Default repo Repository Repository with all the entities. required resource_types Optional[List[str]] Only retrieve the state of these types. None all_ bool Whether to show active and inactive resources. Default: False False inactive bool Whether to show inactive resources. Default: False False Returns: Type Description List[clinv.model.entity.Entity] List of entities that match the criteria Source code in clinv/services.py def list_entities ( repo : Repository , resource_types : Optional [ List [ str ]] = None , all_ : bool = False , inactive : bool = False , ) -> List [ Entity ]: \"\"\"List the resources of the repository. Args: repo: Repository with all the entities. resource_types: Only retrieve the state of these types. all_: Whether to show active and inactive resources. Default: False inactive: Whether to show inactive resources. Default: False Returns: List of entities that match the criteria \"\"\" if resource_types is None or len ( resource_types ) == 0 : models = MODELS else : models = [ RESOURCE_TYPES [ resource_type ] for resource_type in resource_types ] entities = _filter_entities ( repo . all ( models ), all_ , inactive ) if len ( entities ) == 0 : if resource_types is None or len ( resource_types ) == 0 : raise EntityNotFoundError ( \"There are no entities in the repository that match the criteria.\" ) else : raise EntityNotFoundError ( f \"There are no entities of type { ', ' . join ( resource_types ) } in the \" \"repository that match the criteria.\" ) return entities search ( repo , regexp , all_ = False , inactive = False , resource_types = None ) \u00b6 Search resources whose attribute match the regular expression. Parameters: Name Type Description Default repo Repository Repository with all the entities. required regexp str Regular expression that the entity attributes must match. required resource_types Optional[List[str]] Only retrieve the state of these type. None all_ bool Whether to show active and inactive resources. Default: False False inactive bool Whether to show inactive resources. Default: False False Returns: Type Description Generator[List[clinv.model.entity.Entity], NoneType, NoneType] List of entities that match the criteria. Source code in clinv/services.py def search ( repo : Repository , regexp : str , all_ : bool = False , inactive : bool = False , resource_types : Optional [ List [ str ]] = None , ) -> Generator [ List [ Entity ], None , None ]: \"\"\"Search resources whose attribute match the regular expression. Args: repo: Repository with all the entities. regexp: Regular expression that the entity attributes must match. resource_types: Only retrieve the state of these type. all_: Whether to show active and inactive resources. Default: False inactive: Whether to show inactive resources. Default: False Returns: List of entities that match the criteria. \"\"\" if resource_types is None or len ( resource_types ) == 0 : models = MODELS else : models = [ RESOURCE_TYPES [ resource_type ] for resource_type in resource_types ] # Attributes to search attributes = [] for model in models : for attribute in model . schema ()[ \"properties\" ] . keys (): if attribute not in attributes : attributes . append ( attribute ) entities = [] for attribute in attributes : with suppress ( EntityNotFoundError ): new_entities = _filter_entities ( repo . search ({ attribute : regexp }, models ), all_ , inactive ) yield new_entities entities += new_entities if len ( entities ) == 0 : if resource_types is None or len ( resource_types ) == 0 : raise EntityNotFoundError ( \"There are no entities in the repository that match the criteria.\" ) else : raise EntityNotFoundError ( f \"There are no entities of type { ', ' . join ( resource_types ) } in the \" \"repository that match the criteria.\" ) update_sources ( repo , adapter_sources , resource_types ) \u00b6 Update the repository entities with the source adapters current state. Parameters: Name Type Description Default repo Repository Repository with all the entities. required adapter_sources List[~AdapterSource] List of source adapters to check. required resource_types List[str] Only retrieve the state of these types. required Source code in clinv/services.py def update_sources ( repo : Repository , adapter_sources : List [ AdapterSource ], resource_types : List [ str ], ) -> None : \"\"\"Update the repository entities with the source adapters current state. Args: repo: Repository with all the entities. adapter_sources: List of source adapters to check. resource_types: Only retrieve the state of these types. \"\"\" resource_models = [ RESOURCE_TYPES [ resource_type ] for resource_type in resource_types ] try : active_resources = repo . search ({ \"state\" : \"active\" }, resource_models ) except EntityNotFoundError : active_resources = [] for source in adapter_sources : source_updates = source . update ( resource_types , active_resources ) for entity_data in track ( source_updates , description = \"Updating repo data\" ): entity = entity_data . model ( ** entity_data . data ) repo . add ( entity ) log . info ( \"Committing changes\" ) repo . commit () version \u00b6 Utilities to retrieve the information of the program version. version_info () \u00b6 Display the version of the program, python and the platform. Source code in clinv/version.py def version_info () -> str : \"\"\"Display the version of the program, python and the platform.\"\"\" info = { \"clinv version\" : __version__ , \"python version\" : sys . version . replace ( \" \\n \" , \" \" ), \"platform\" : platform . platform (), } return \" \\n \" . join ( f \" { k + ':' : >30 } { v } \" for k , v in info . items ()) views \u00b6 Define the representations of the data. add_entities_to_table ( table , entities ) \u00b6 Add rows to a list table of entities. Source code in clinv/views.py def add_entities_to_table ( table : Table , entities : List [ Entity ]) -> None : \"\"\"Add rows to a list table of entities.\"\"\" for entity in entities : table . add_row ( str ( entity . id_ ), entity . name , entity . _model_name ) get_data_to_print ( entity ) \u00b6 Prepare the Entity attributes data to be printed. Parameters: Name Type Description Default entity Entity Entity to extract the data from. required Returns: Type Description List[Dict[str, Any]] Source code in clinv/views.py def get_data_to_print ( entity : Entity ) -> List [ Dict [ str , Any ]]: \"\"\"Prepare the Entity attributes data to be printed. Args: entity: Entity to extract the data from. Returns: attributes: Dictionary with the attribute description and value \"\"\" # W0212: accessed to a private attribute, but we need it to be that way attrs_list : List [ Dict [ str , Any ]] = [ { \"_model_name\" : entity . _model_name } # noqa: W0212 ] for key , value in entity . dict () . items (): key = _snake_to_upper ( key ) if key == \"Id \" : key = \"ID\" if value is None or value == \"\" : continue elif isinstance ( value , str ): attrs_list [ 0 ][ key ] = value elif isinstance ( value , ( bool , int )): attrs_list [ 0 ][ key ] = str ( value ) elif isinstance ( value , list ): if len ( value ) == 0 : continue elif isinstance ( value [ 0 ], ( str , int )): try : attrs_list [ 0 ][ key ] = \" \\n \" . join ( value ) except TypeError : # We don't yet have any entity with type List[int] so we can't # test this functionality yet attrs_list [ 0 ][ key ] = \" \\n \" . join ([ str ( element ) for element in value ]) else : with suppress ( AttributeError ): submodel_attrs : Dict [ str , Any ] = { \"_model_name\" : key , \"header\" : [ _snake_to_upper ( attr_name ) for attr_name in value [ 0 ] . keys () ], \"elements\" : [], } for sub_value in value : row = [] for _ , sub_attr in sub_value . items (): if sub_attr is None or isinstance ( sub_attr , ( str , int )): row . append ( sub_attr ) elif isinstance ( sub_attr , list ): try : row . append ( \" \\n \" . join ( sub_attr )) except TypeError : row . append ( \" \\n \" . join ( [ str ( element ) for element in sub_attr ] ) ) submodel_attrs [ \"elements\" ] . append ( row ) attrs_list . append ( submodel_attrs ) return attrs_list list_entities ( entities ) \u00b6 Print the list of entities. Source code in clinv/views.py def list_entities ( entities : List [ Entity ]) -> None : \"\"\"Print the list of entities.\"\"\" table = Table ( box = box . MINIMAL_HEAVY_HEAD ) table . add_column ( \"ID\" , justify = \"left\" , style = \"green\" ) table . add_column ( \"Name\" , justify = \"left\" , style = \"magenta\" ) table . add_column ( \"Type\" , justify = \"center\" , style = \"cyan\" ) add_entities_to_table ( table , entities ) console = Console () console . print ( table ) print_entity ( entity ) \u00b6 Print the entity attributes. Parameters: Name Type Description Default entity Entity Entity whose attributes to print. required Source code in clinv/views.py def print_entity ( entity : Entity ) -> None : \"\"\"Print the entity attributes. Args: entity: Entity whose attributes to print. \"\"\" data = get_data_to_print ( entity ) console = Console () # There are two types of data to print, one contains the attributes of an # element, and the other contains a list of element attributes. The last case # is common of attributes that contain a list of other Pydantic objects. for attr_group in data : model_name = attr_group . pop ( \"_model_name\" ) if \"header\" in attr_group : table = Table ( box = box . MINIMAL_HEAVY_HEAD , title = model_name ) for header in attr_group [ \"header\" ]: table . add_column ( header , justify = \"left\" ) for element in attr_group [ \"elements\" ]: table . add_row ( * element ) else : table = Table ( box = box . MINIMAL_HEAVY_HEAD ) table . add_column ( \"Type\" , justify = \"left\" , style = \"green\" ) table . add_column ( model_name , justify = \"left\" ) for attribute , value in attr_group . items (): table . add_row ( attribute , value ) console . print ( table )","title":"Reference"},{"location":"reference/#clinv","text":"Define the package importable objects.","title":"clinv"},{"location":"reference/#clinv.adapters","text":"Store the exposed adapters.","title":"adapters"},{"location":"reference/#clinv.adapters.abstract","text":"Define the interface for the source adapters.","title":"abstract"},{"location":"reference/#clinv.adapters.abstract.AbstractSource","text":"Define common methods and define the interface of the source adapters.","title":"AbstractSource"},{"location":"reference/#clinv.adapters.abstract.AbstractSource.update","text":"Get the latest state of the source entities. Parameters: Name Type Description Default resource_types Optional[List[str]] Limit the update to these type of resources. None active_resources Optional[List[~EntityType]] List of active resources in the repository. None Returns: Type Description List[clinv.model.entity.EntityUpdate] List of entity updates. Source code in clinv/adapters/abstract.py @abc . abstractmethod def update ( self , resource_types : Optional [ List [ str ]] = None , active_resources : Optional [ List [ EntityType ]] = None , ) -> List [ EntityUpdate ]: \"\"\"Get the latest state of the source entities. Args: resource_types: Limit the update to these type of resources. active_resources: List of active resources in the repository. Returns: List of entity updates. \"\"\" raise NotImplementedError","title":"update()"},{"location":"reference/#clinv.adapters.aws","text":"Define the AWS sources used by Clinv.","title":"aws"},{"location":"reference/#clinv.adapters.aws.AWSSource","text":"Define the interface to interact with the source of AWS entities.","title":"AWSSource"},{"location":"reference/#clinv.adapters.aws.AWSSource.regions","text":"Get the AWS regions. Returns: Type Description List[str]","title":"regions"},{"location":"reference/#clinv.adapters.aws.AWSSource.update","text":"Get the latest state of the source entities. Parameters: Name Type Description Default resource_types Optional[List[str]] Limit the update to these type of resources. None active_resources Optional[List[~EntityType]] List of active resources in the repository. None Returns: Type Description List[clinv.model.entity.EntityUpdate] List of entity updates. Source code in clinv/adapters/aws.py def update ( self , resource_types : Optional [ List [ str ]] = None , active_resources : Optional [ List [ EntityType ]] = None , ) -> List [ EntityUpdate ]: \"\"\"Get the latest state of the source entities. Args: resource_types: Limit the update to these type of resources. active_resources: List of active resources in the repository. Returns: List of entity updates. \"\"\" log . info ( \"Updating AWS entities.\" ) update_mapper = { \"asg\" : self . _update_asg , \"ec2\" : self . _update_ec2 , \"iamg\" : self . _update_iam_groups , \"iamu\" : self . _update_iam_users , \"s3\" : self . _update_s3 , \"sg\" : self . _update_sg , \"rds\" : self . _update_rds , \"r53\" : self . _update_route53 , \"vpc\" : self . _update_vpc , } if resource_types is None : resource_types = list ( update_mapper . keys ()) else : # Only process the AWS resources resource_types = [ resource_type for resource_type in resource_types if resource_type in update_mapper ] entity_updates = [] if active_resources is None : remaining_entities = [] else : remaining_entities = active_resources # Create entity updates for resource_type in track ( resource_types , description = \"Get AWS data\" ): with suppress ( KeyError ): entity_updates += update_mapper [ resource_type ]( remaining_entities ) # Mark entities that were no present in the updates as terminated resource_models = [ RESOURCE_TYPES [ resource_type ] for resource_type in resource_types ] for entity in remaining_entities : if type ( entity ) in resource_models : log . info ( f \"Marking ' { entity . _model_name } ' with id ' { entity . id_ } ' and name \" f \"' { entity . name } ' as terminated\" ) entity . state = EntityState . TERMINATED entity_updates . append ( EntityUpdate ( model = type ( entity ), data = entity . dict ()) ) return entity_updates","title":"update()"},{"location":"reference/#clinv.adapters.aws.build_security_group_rule_data","text":"Adapt the security group rule from the AWS format to the SecurityGroupRule. Parameters: Name Type Description Default rule_data Dict[str, Any] dictionary of the security group data. required Returns: Type Description Dict[str, Any] dictionary compatible with the SecurityGroupRule fields. Source code in clinv/adapters/aws.py def build_security_group_rule_data ( rule_data : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\"Adapt the security group rule from the AWS format to the SecurityGroupRule. Args: rule_data: dictionary of the security group data. Returns: dictionary compatible with the SecurityGroupRule fields. \"\"\" rule = { \"protocol\" : rule_data [ \"IpProtocol\" ] . upper (), \"ip_range\" : [], \"ipv6_range\" : [], \"sg_range\" : [], } if rule [ \"protocol\" ] == \"ICMP\" : rule [ \"ports\" ] = [ - 2 ] elif rule [ \"protocol\" ] == \"-1\" : rule [ \"protocol\" ] = \"TCP & UDP & ICMP\" rule [ \"ports\" ] = [ - 1 ] else : rule [ \"ports\" ] = list ( range ( rule_data [ \"FromPort\" ], rule_data [ \"ToPort\" ] + 1 )) with suppress ( KeyError ): rule [ \"ip_range\" ] = [ cidr [ \"CidrIp\" ] for cidr in rule_data [ \"IpRanges\" ]] with suppress ( KeyError ): rule [ \"ipv6_range\" ] = [ cidr [ \"CidrIp\" ] for cidr in rule_data [ \"Ipv6Ranges\" ]] with suppress ( KeyError ): rule [ \"sg_range\" ] = [ sg [ \"GroupId\" ] for sg in rule_data [ \"UserIdGroupPairs\" ]] # The description of the security group rules is attached to each of the # elements of the lists. for description_place in [ \"IpRanges\" , \"Ipv6Ranges\" , \"UserIdGroupPairs\" ]: with suppress ( KeyError , IndexError ): rule [ \"description\" ] = [ cidr [ \"Description\" ] for cidr in rule_data [ description_place ] ][ 0 ] break return rule","title":"build_security_group_rule_data()"},{"location":"reference/#clinv.adapters.fake","text":"Define the fake adapters used for testing.","title":"fake"},{"location":"reference/#clinv.adapters.fake.FakeSource","text":"Define Fake source to be used in the edge to edge tests.","title":"FakeSource"},{"location":"reference/#clinv.adapters.fake.FakeSource.__init__","text":"Initialize the source attributes. Parameters: Name Type Description Default supported_models List of models supported by the source. required Source code in clinv/adapters/fake.py def __init__ ( self ) -> None : \"\"\"Initialize the source attributes. Args: supported_models: List of models supported by the source. \"\"\" self . supported_models : List [ str ] = [ \"Entity\" ] self . _entity_updates : List [ EntityUpdate ] = []","title":"__init__()"},{"location":"reference/#clinv.adapters.fake.FakeSource.add_change","text":"Record changes on entities to be returned when calling the update method. Parameters: Name Type Description Default entity_data Dict[str, Any] dictionary with key value to update. required Source code in clinv/adapters/fake.py def add_change ( self , entity : EntityType , entity_data : Dict [ str , Any ]) -> None : \"\"\"Record changes on entities to be returned when calling the update method. Args: entity_data: dictionary with key value to update. \"\"\" entity_data [ \"id_\" ] = entity . id_ entity_data [ \"model\" ] = type ( entity ) self . _entity_updates . append ( EntityUpdate ( data = { ** entity . dict (), ** entity_data }))","title":"add_change()"},{"location":"reference/#clinv.adapters.fake.FakeSource.update","text":"Get the latest state of the source entities. Parameters: Name Type Description Default resource_types Optional[List[str]] Limit the update to these type of resources. None active_resources Optional[List[~EntityType]] List of active resources in the repository. None Returns: Type Description List[clinv.model.entity.EntityUpdate] List of entity updates. Source code in clinv/adapters/fake.py def update ( self , resource_types : Optional [ List [ str ]] = None , active_resources : Optional [ List [ EntityType ]] = None , ) -> List [ EntityUpdate ]: \"\"\"Get the latest state of the source entities. Args: resource_types: Limit the update to these type of resources. active_resources: List of active resources in the repository. Returns: List of entity updates. \"\"\" return self . _entity_updates","title":"update()"},{"location":"reference/#clinv.adapters.risk","text":"Define the Risk management sources used by Clinv.","title":"risk"},{"location":"reference/#clinv.adapters.risk.RiskSource","text":"Define the interface to interact with the source of Risk Management entities.","title":"RiskSource"},{"location":"reference/#clinv.adapters.risk.RiskSource.update","text":"Get the latest state of the source entities. Parameters: Name Type Description Default resource_types Optional[List[str]] Limit the update to these type of resources. None active_resources Optional[List[~EntityType]] List of active resources in the repository. None Returns: Type Description List[clinv.model.entity.EntityUpdate] List of entity updates. Source code in clinv/adapters/risk.py def update ( self , resource_types : Optional [ List [ str ]] = None , active_resources : Optional [ List [ EntityType ]] = None , ) -> List [ EntityUpdate ]: \"\"\"Get the latest state of the source entities. Args: resource_types: Limit the update to these type of resources. active_resources: List of active resources in the repository. Returns: List of entity updates. \"\"\" log . debug ( \"Updating Risk Management entities.\" ) return []","title":"update()"},{"location":"reference/#clinv.config","text":"Define the configuration of the main program.","title":"config"},{"location":"reference/#clinv.config.Config","text":"Expose the configuration in a friendly way. Public methods: get: Fetch the configuration value of the specified key. load: Load the configuration from the configuration YAML file. save: Saves the configuration in the configuration YAML file. Attributes and properties: config_path (str): Path to the configuration file. data(dict): Program configuration.","title":"Config"},{"location":"reference/#clinv.config.Config.__init__","text":"Configure the attributes and load the configuration. Source code in clinv/config.py def __init__ ( self , config_path : str = \"~/.local/share/clinv/config.yaml\" ) -> None : \"\"\"Configure the attributes and load the configuration.\"\"\" super () . __init__ () self . config_path = os . path . expanduser ( config_path ) self . load ()","title":"__init__()"},{"location":"reference/#clinv.config.Config.get","text":"Fetch the configuration value of the specified key. If there are nested dictionaries, a dot notation can be used. So if the configuration contents are: self.data = { 'first': { 'second': 'value' }, } self.data.get('first.second') == 'value' Source code in clinv/config.py def get ( self , key : str , default : Any = None ) -> Union [ str , int , Dict [ str , Any ], List [ Any ]]: \"\"\"Fetch the configuration value of the specified key. If there are nested dictionaries, a dot notation can be used. So if the configuration contents are: self.data = { 'first': { 'second': 'value' }, } self.data.get('first.second') == 'value' \"\"\" original_key = key config_keys = key . split ( \".\" ) value = self . data . copy () for config_key in config_keys : try : value = value [ config_key ] except KeyError as error : if default is not None : return default raise ConfigError ( f \"Failed to fetch the configuration { config_key } \" f \"when searching for { original_key } \" ) from error return value","title":"get()"},{"location":"reference/#clinv.config.Config.load","text":"Load the configuration from the configuration YAML file. Source code in clinv/config.py def load ( self ) -> None : \"\"\"Load the configuration from the configuration YAML file.\"\"\" try : with open ( os . path . expanduser ( self . config_path ), \"r\" ) as file_cursor : try : self . data = YAML () . load ( file_cursor ) except ( ParserError , ScannerError ) as error : raise ConfigError ( str ( error )) from error except FileNotFoundError as error : raise ConfigError ( f \"The configuration file { self . config_path } could not be found.\" ) from error","title":"load()"},{"location":"reference/#clinv.config.Config.save","text":"Save the configuration in the configuration YAML file. Source code in clinv/config.py def save ( self ) -> None : \"\"\"Save the configuration in the configuration YAML file.\"\"\" with open ( os . path . expanduser ( self . config_path ), \"w+\" ) as file_cursor : yaml = YAML () yaml . default_flow_style = False yaml . dump ( self . data , file_cursor )","title":"save()"},{"location":"reference/#clinv.config.Config.set","text":"Set the configuration value of the specified key. If there are nested dictionaries, a dot notation can be used. So if you want to set the configuration: self.data = { 'first': { 'second': 'value' }, } self.data.set('first.second', 'value') Source code in clinv/config.py def set ( self , key : str , value : Union [ str , int ]) -> None : \"\"\"Set the configuration value of the specified key. If there are nested dictionaries, a dot notation can be used. So if you want to set the configuration: self.data = { 'first': { 'second': 'value' }, } self.data.set('first.second', 'value') \"\"\" config_keys : List [ str ] = key . split ( \".\" ) last_key = config_keys . pop ( - 1 ) # Initialize the dictionary structure parent = self . data for config_key in config_keys : try : parent = parent [ config_key ] except KeyError : parent [ config_key ] = {} parent = parent [ config_key ] # Set value parent [ last_key ] = value","title":"set()"},{"location":"reference/#clinv.config.ConfigError","text":"Catch configuration errors.","title":"ConfigError"},{"location":"reference/#clinv.entrypoints","text":"Define the different ways to expose the program functionality. Functions load_logger: Configure the Logging logger.","title":"entrypoints"},{"location":"reference/#clinv.entrypoints.load_adapters","text":"Configure the source adapters. Parameters: Name Type Description Default config Config program configuration object. required Returns: Type Description List[~AdapterSource] List of configured sources adapters to work with. Source code in clinv/entrypoints/__init__.py def load_adapters ( config : Config ) -> List [ AdapterSource ]: \"\"\"Configure the source adapters. Args: config: program configuration object. Returns: List of configured sources adapters to work with. \"\"\" sources : List [ AdapterSource ] = [] log . debug ( \"Initializing the adapters\" ) for source_name in config [ \"sources\" ]: # ignore. AdapterSource is not callable. I still don't know how to fix this. sources . append ( AVAILABLE_SOURCES [ source_name ]()) # type: ignore return sources","title":"load_adapters()"},{"location":"reference/#clinv.entrypoints.load_config","text":"Load the configuration from the file. Source code in clinv/entrypoints/__init__.py def load_config ( config_path : str ) -> Config : \"\"\"Load the configuration from the file.\"\"\" log . debug ( f \"Loading the configuration from file { config_path } \" ) try : config = Config ( config_path ) except ConfigError as error : log . error ( f \"Error parsing yaml of configuration file { config_path } : { str ( error ) } \" ) sys . exit ( 1 ) return config","title":"load_config()"},{"location":"reference/#clinv.entrypoints.load_logger","text":"Configure the Logging logger. Parameters: Name Type Description Default verbose bool Set the logging level to Debug. False Source code in clinv/entrypoints/__init__.py def load_logger ( verbose : bool = False ) -> None : # pragma: no cover \"\"\"Configure the Logging logger. Args: verbose: Set the logging level to Debug. \"\"\" logging . getLogger ( \"boto3\" ) . setLevel ( logging . WARNING ) logging . getLogger ( \"botocore\" ) . setLevel ( logging . WARNING ) if verbose : logging . basicConfig ( stream = sys . stderr , level = logging . DEBUG , format = \" %(message)s \" ) else : logging . basicConfig ( level = logging . INFO , format = \" %(message)s \" , datefmt = \"[ %X ]\" , handlers = [ RichHandler ( rich_tracebacks = True )], )","title":"load_logger()"},{"location":"reference/#clinv.entrypoints.cli","text":"Command line interface definition.","title":"cli"},{"location":"reference/#clinv.model","text":"Module to store the common business model of all entities.","title":"model"},{"location":"reference/#clinv.model.aws","text":"Define the models of the AWS resources.","title":"aws"},{"location":"reference/#clinv.model.aws.ASG","text":"Represent an AWS ASG. Parameters: Name Type Description Default description required environment Logical environment (production, staging). required id_ unique identifier of the entity. required monitor If the instance is being monitored required name required region AWS region where the instance lives. For example us-east-1 required state required min_size required max_size required desired_size required launch_configuration required launch_template required availability_zones required instances List of instance ids of the autoscaling group required healthcheck if the healthcheck is of type EC2 or ELB required","title":"ASG"},{"location":"reference/#clinv.model.aws.AWSEntity","text":"Represent a generic AWS resource. Parameters: Name Type Description Default start_date required monitor If the instance is being monitored required environment Logical environment (production, staging) required","title":"AWSEntity"},{"location":"reference/#clinv.model.aws.EC2","text":"Represent an Elastic Compute Cloud AWS instance. Parameters: Name Type Description Default ami AMI base image. required description required environment Logical environment (production, staging) required id_ unique identifier of the entity. required monitor If the instance is being monitored required name required private_ips required public_ips required security_groups List of security groups id's attached to the instance. required region AWS region where the instance lives. For example us-east-1 required size Instance type. required start_date required state required subnet required vpc required","title":"EC2"},{"location":"reference/#clinv.model.aws.IAMGroup","text":"Represent an IAM user. Parameters: Name Type Description Default arn AWS ARN identifier of the resource. required users list of users ids. required","title":"IAMGroup"},{"location":"reference/#clinv.model.aws.IAMUser","text":"Represent an IAM user. Parameters: Name Type Description Default arn AWS ARN identifier of the resource. required","title":"IAMUser"},{"location":"reference/#clinv.model.aws.NetworkProtocol","text":"Set the possible network protocols.","title":"NetworkProtocol"},{"location":"reference/#clinv.model.aws.RDS","text":"Represent an AWS RDS database. Parameters: Name Type Description Default description required engine Database type and version. required endpoint Endpoint to connect to the database required environment Logical environment (production, staging) required id_ unique identifier of the entity. required monitor If the instance is being monitored required name required security_groups List of security groups id's attached to the instance. required region AWS region where the instance lives. For example us-east-1 required size Instance type. required start_date required state required subnets required vpc required","title":"RDS"},{"location":"reference/#clinv.model.aws.Route53","text":"Represent an AWS Route53 record. Parameters: Name Type Description Default description required environment Logical environment (production, staging) required id_ unique identifier of the entity. required monitor If the instance is being monitored required name required state required hosted_zone AWS HostedZone containing the record. required value Where does the record point to, or the information it holds. required type_ Record type. Such as A or CNAME . required public If the record is accessed by the general public. required","title":"Route53"},{"location":"reference/#clinv.model.aws.S3","text":"Represent an AWS S3 bucket. Parameters: Name Type Description Default description required public_read If anyone has public read permissions on the bucket. required public_write If anyone has public write permissions on the bucket. required environment Logical environment (production, staging) required id_ unique identifier of the entity. required monitor If the instance is being monitored required name required start_date required state required","title":"S3"},{"location":"reference/#clinv.model.aws.SecurityGroup","text":"Represent an AWS Security Group. Parameters: Name Type Description Default description required environment Logical environment (production, staging). required id_ unique identifier of the entity. required monitor If the instance is being monitored required name required region AWS region where the instance lives. For example us-east-1 required state required","title":"SecurityGroup"},{"location":"reference/#clinv.model.aws.SecurityGroupRule","text":"Represent an AWS Security Group Rule. Parameters: Name Type Description Default protocol required ports List of ports to open. To model the special cases we use negative ints: * All ports: -1 * Not applicable: -2. For example for ICMP. required ip_range List of ips that are related to the rule. required ipv6_range List of ips of version 6 that are related to the rule. required sg_range List of security group ids that are related to the rule. required","title":"SecurityGroupRule"},{"location":"reference/#clinv.model.aws.VPC","text":"Represent an AWS VPC. Parameters: Name Type Description Default description required environment Logical environment (production, staging) required id_ unique identifier of the entity. required monitor If the instance is being monitored required cidr required name required region AWS region where the instance lives. For example us-east-1 required state required","title":"VPC"},{"location":"reference/#clinv.model.entity","text":"Define the basic entity.","title":"entity"},{"location":"reference/#clinv.model.entity.Entity","text":"Define the generic clinv entity. Parameters: Name Type Description Default id_ unique identifier of the entity. required name required state required description required","title":"Entity"},{"location":"reference/#clinv.model.entity.EntityState","text":"Set the possible entity states.","title":"EntityState"},{"location":"reference/#clinv.model.entity.EntityUpdate","text":"Define the updates of an entity.","title":"EntityUpdate"},{"location":"reference/#clinv.model.entity.EntityUpdate.set_id_and_model","text":"Set the id_ and model attributes. Source code in clinv/model/entity.py @root_validator ( pre = True ) @classmethod def set_id_and_model ( cls , values : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\"Set the id_ and model attributes.\"\"\" values [ \"id_\" ] = values [ \"data\" ][ \"id_\" ] with suppress ( KeyError ): values [ \"model\" ] = values [ \"data\" ] . pop ( \"model\" ) return values","title":"set_id_and_model()"},{"location":"reference/#clinv.model.entity.Environment","text":"Set the possible logical environments.","title":"Environment"},{"location":"reference/#clinv.model.risk","text":"Define the Risk management entities.","title":"risk"},{"location":"reference/#clinv.model.risk.Information","text":"Represent the data used by a service or project. Parameters: Name Type Description Default id_ unique identifier of the entity. required name required state required description required personal_data Whether the information contains personal data in terms of RGPD. required responsible Person who is legally responsible of the entity. required","title":"Information"},{"location":"reference/#clinv.model.risk.People","text":"Represent the people of the team. Parameters: Name Type Description Default id_ unique identifier of the entity. required name required state required description required iam_user required email required","title":"People"},{"location":"reference/#clinv.model.risk.Project","text":"Represent the reason for a group of service and information. Parameters: Name Type Description Default id_ unique identifier of the entity. required name required state required description required aliases Alternative names of the project. required services Service ids used by the project. required informations Information ids used by the project. required people People ids that work on the project. required responsible Person who is legally responsible of the entity. required","title":"Project"},{"location":"reference/#clinv.model.risk.Service","text":"Represent aggregation of IT resources to present an utility to users. Parameters: Name Type Description Default id_ unique identifier of the entity. required name required state required description required authentication List of authentication methods required to access the service. required environment Logical environment (production, staging) required access Level of exposition of the resource. required responsible Person who is legally responsible of the entity. required informations Information ids used by the project. required","title":"Service"},{"location":"reference/#clinv.model.risk.ServiceAccess","text":"Represent possible states of the service access.","title":"ServiceAccess"},{"location":"reference/#clinv.services","text":"Gather all the orchestration functionality required by the program to work. Classes and functions that connect the different domain model objects with the adapters and handlers to achieve the program's purpose.","title":"services"},{"location":"reference/#clinv.services.list_entities","text":"List the resources of the repository. Parameters: Name Type Description Default repo Repository Repository with all the entities. required resource_types Optional[List[str]] Only retrieve the state of these types. None all_ bool Whether to show active and inactive resources. Default: False False inactive bool Whether to show inactive resources. Default: False False Returns: Type Description List[clinv.model.entity.Entity] List of entities that match the criteria Source code in clinv/services.py def list_entities ( repo : Repository , resource_types : Optional [ List [ str ]] = None , all_ : bool = False , inactive : bool = False , ) -> List [ Entity ]: \"\"\"List the resources of the repository. Args: repo: Repository with all the entities. resource_types: Only retrieve the state of these types. all_: Whether to show active and inactive resources. Default: False inactive: Whether to show inactive resources. Default: False Returns: List of entities that match the criteria \"\"\" if resource_types is None or len ( resource_types ) == 0 : models = MODELS else : models = [ RESOURCE_TYPES [ resource_type ] for resource_type in resource_types ] entities = _filter_entities ( repo . all ( models ), all_ , inactive ) if len ( entities ) == 0 : if resource_types is None or len ( resource_types ) == 0 : raise EntityNotFoundError ( \"There are no entities in the repository that match the criteria.\" ) else : raise EntityNotFoundError ( f \"There are no entities of type { ', ' . join ( resource_types ) } in the \" \"repository that match the criteria.\" ) return entities","title":"list_entities()"},{"location":"reference/#clinv.services.search","text":"Search resources whose attribute match the regular expression. Parameters: Name Type Description Default repo Repository Repository with all the entities. required regexp str Regular expression that the entity attributes must match. required resource_types Optional[List[str]] Only retrieve the state of these type. None all_ bool Whether to show active and inactive resources. Default: False False inactive bool Whether to show inactive resources. Default: False False Returns: Type Description Generator[List[clinv.model.entity.Entity], NoneType, NoneType] List of entities that match the criteria. Source code in clinv/services.py def search ( repo : Repository , regexp : str , all_ : bool = False , inactive : bool = False , resource_types : Optional [ List [ str ]] = None , ) -> Generator [ List [ Entity ], None , None ]: \"\"\"Search resources whose attribute match the regular expression. Args: repo: Repository with all the entities. regexp: Regular expression that the entity attributes must match. resource_types: Only retrieve the state of these type. all_: Whether to show active and inactive resources. Default: False inactive: Whether to show inactive resources. Default: False Returns: List of entities that match the criteria. \"\"\" if resource_types is None or len ( resource_types ) == 0 : models = MODELS else : models = [ RESOURCE_TYPES [ resource_type ] for resource_type in resource_types ] # Attributes to search attributes = [] for model in models : for attribute in model . schema ()[ \"properties\" ] . keys (): if attribute not in attributes : attributes . append ( attribute ) entities = [] for attribute in attributes : with suppress ( EntityNotFoundError ): new_entities = _filter_entities ( repo . search ({ attribute : regexp }, models ), all_ , inactive ) yield new_entities entities += new_entities if len ( entities ) == 0 : if resource_types is None or len ( resource_types ) == 0 : raise EntityNotFoundError ( \"There are no entities in the repository that match the criteria.\" ) else : raise EntityNotFoundError ( f \"There are no entities of type { ', ' . join ( resource_types ) } in the \" \"repository that match the criteria.\" )","title":"search()"},{"location":"reference/#clinv.services.update_sources","text":"Update the repository entities with the source adapters current state. Parameters: Name Type Description Default repo Repository Repository with all the entities. required adapter_sources List[~AdapterSource] List of source adapters to check. required resource_types List[str] Only retrieve the state of these types. required Source code in clinv/services.py def update_sources ( repo : Repository , adapter_sources : List [ AdapterSource ], resource_types : List [ str ], ) -> None : \"\"\"Update the repository entities with the source adapters current state. Args: repo: Repository with all the entities. adapter_sources: List of source adapters to check. resource_types: Only retrieve the state of these types. \"\"\" resource_models = [ RESOURCE_TYPES [ resource_type ] for resource_type in resource_types ] try : active_resources = repo . search ({ \"state\" : \"active\" }, resource_models ) except EntityNotFoundError : active_resources = [] for source in adapter_sources : source_updates = source . update ( resource_types , active_resources ) for entity_data in track ( source_updates , description = \"Updating repo data\" ): entity = entity_data . model ( ** entity_data . data ) repo . add ( entity ) log . info ( \"Committing changes\" ) repo . commit ()","title":"update_sources()"},{"location":"reference/#clinv.version","text":"Utilities to retrieve the information of the program version.","title":"version"},{"location":"reference/#clinv.version.version_info","text":"Display the version of the program, python and the platform. Source code in clinv/version.py def version_info () -> str : \"\"\"Display the version of the program, python and the platform.\"\"\" info = { \"clinv version\" : __version__ , \"python version\" : sys . version . replace ( \" \\n \" , \" \" ), \"platform\" : platform . platform (), } return \" \\n \" . join ( f \" { k + ':' : >30 } { v } \" for k , v in info . items ())","title":"version_info()"},{"location":"reference/#clinv.views","text":"Define the representations of the data.","title":"views"},{"location":"reference/#clinv.views.add_entities_to_table","text":"Add rows to a list table of entities. Source code in clinv/views.py def add_entities_to_table ( table : Table , entities : List [ Entity ]) -> None : \"\"\"Add rows to a list table of entities.\"\"\" for entity in entities : table . add_row ( str ( entity . id_ ), entity . name , entity . _model_name )","title":"add_entities_to_table()"},{"location":"reference/#clinv.views.get_data_to_print","text":"Prepare the Entity attributes data to be printed. Parameters: Name Type Description Default entity Entity Entity to extract the data from. required Returns: Type Description List[Dict[str, Any]] Source code in clinv/views.py def get_data_to_print ( entity : Entity ) -> List [ Dict [ str , Any ]]: \"\"\"Prepare the Entity attributes data to be printed. Args: entity: Entity to extract the data from. Returns: attributes: Dictionary with the attribute description and value \"\"\" # W0212: accessed to a private attribute, but we need it to be that way attrs_list : List [ Dict [ str , Any ]] = [ { \"_model_name\" : entity . _model_name } # noqa: W0212 ] for key , value in entity . dict () . items (): key = _snake_to_upper ( key ) if key == \"Id \" : key = \"ID\" if value is None or value == \"\" : continue elif isinstance ( value , str ): attrs_list [ 0 ][ key ] = value elif isinstance ( value , ( bool , int )): attrs_list [ 0 ][ key ] = str ( value ) elif isinstance ( value , list ): if len ( value ) == 0 : continue elif isinstance ( value [ 0 ], ( str , int )): try : attrs_list [ 0 ][ key ] = \" \\n \" . join ( value ) except TypeError : # We don't yet have any entity with type List[int] so we can't # test this functionality yet attrs_list [ 0 ][ key ] = \" \\n \" . join ([ str ( element ) for element in value ]) else : with suppress ( AttributeError ): submodel_attrs : Dict [ str , Any ] = { \"_model_name\" : key , \"header\" : [ _snake_to_upper ( attr_name ) for attr_name in value [ 0 ] . keys () ], \"elements\" : [], } for sub_value in value : row = [] for _ , sub_attr in sub_value . items (): if sub_attr is None or isinstance ( sub_attr , ( str , int )): row . append ( sub_attr ) elif isinstance ( sub_attr , list ): try : row . append ( \" \\n \" . join ( sub_attr )) except TypeError : row . append ( \" \\n \" . join ( [ str ( element ) for element in sub_attr ] ) ) submodel_attrs [ \"elements\" ] . append ( row ) attrs_list . append ( submodel_attrs ) return attrs_list","title":"get_data_to_print()"},{"location":"reference/#clinv.views.list_entities","text":"Print the list of entities. Source code in clinv/views.py def list_entities ( entities : List [ Entity ]) -> None : \"\"\"Print the list of entities.\"\"\" table = Table ( box = box . MINIMAL_HEAVY_HEAD ) table . add_column ( \"ID\" , justify = \"left\" , style = \"green\" ) table . add_column ( \"Name\" , justify = \"left\" , style = \"magenta\" ) table . add_column ( \"Type\" , justify = \"center\" , style = \"cyan\" ) add_entities_to_table ( table , entities ) console = Console () console . print ( table )","title":"list_entities()"},{"location":"reference/#clinv.views.print_entity","text":"Print the entity attributes. Parameters: Name Type Description Default entity Entity Entity whose attributes to print. required Source code in clinv/views.py def print_entity ( entity : Entity ) -> None : \"\"\"Print the entity attributes. Args: entity: Entity whose attributes to print. \"\"\" data = get_data_to_print ( entity ) console = Console () # There are two types of data to print, one contains the attributes of an # element, and the other contains a list of element attributes. The last case # is common of attributes that contain a list of other Pydantic objects. for attr_group in data : model_name = attr_group . pop ( \"_model_name\" ) if \"header\" in attr_group : table = Table ( box = box . MINIMAL_HEAVY_HEAD , title = model_name ) for header in attr_group [ \"header\" ]: table . add_column ( header , justify = \"left\" ) for element in attr_group [ \"elements\" ]: table . add_row ( * element ) else : table = Table ( box = box . MINIMAL_HEAVY_HEAD ) table . add_column ( \"Type\" , justify = \"left\" , style = \"green\" ) table . add_column ( model_name , justify = \"left\" ) for attribute , value in attr_group . items (): table . add_row ( attribute , value ) console . print ( table )","title":"print_entity()"},{"location":"report/","text":"Report creation \u00b6 If you want to see similar reports go to clinv/reports/ . Create the report test class \u00b6 On test/reports/ create your report class from this template. Substitute {{ class_name }} (for example PrintReport ) and {{ module_path }} (for example print ) with your values. from tests.reports import ClinvReportBaseTestClass from clinv.reports. {{ module_path }} import {{ class_name }} import unittest class Test {{ class_name }}( ClinvReportBaseTestClass , unittest . TestCase ): ''' Test the {{ class_name }} implementation. ''' def setUp ( self ): super () . setUp () self . report = {{ class_name }}( self . inventory ) def tearDown ( self ): super () . tearDown () def test_output_method ( self ): self . report . output () self . assertTrue ( False ) Create the report class \u00b6 On clinv/sources/ create your source class from this template. Substitute {{ class_name }} and {{ class_id }} with your values. \"\"\" Module to store the {{ class_name }}. Classes: {{ class_name }}: {{ class_description }} \"\"\" from clinv.reports import ClinvReport class {{ class_name }}( ClinvReport ): \"\"\" {{ class_description }} Parameters: inventory (Inventory): Clinv inventory object. Public methods: output: Print the report to stdout. Public attributes: inv (Inventory): Clinv inventory. \"\"\" def __init__ ( self , inventory ): super () . __init__ ( inventory ) def output ( self , resource_id ): \"\"\" Method to print the report to stdout. Parameters: resource_id (str): regular expression of a resource id. Returns: stdout: Resource information \"\"\"","title":"Report creation"},{"location":"report/#report-creation","text":"If you want to see similar reports go to clinv/reports/ .","title":"Report creation"},{"location":"report/#create-the-report-test-class","text":"On test/reports/ create your report class from this template. Substitute {{ class_name }} (for example PrintReport ) and {{ module_path }} (for example print ) with your values. from tests.reports import ClinvReportBaseTestClass from clinv.reports. {{ module_path }} import {{ class_name }} import unittest class Test {{ class_name }}( ClinvReportBaseTestClass , unittest . TestCase ): ''' Test the {{ class_name }} implementation. ''' def setUp ( self ): super () . setUp () self . report = {{ class_name }}( self . inventory ) def tearDown ( self ): super () . tearDown () def test_output_method ( self ): self . report . output () self . assertTrue ( False )","title":"Create the report test class"},{"location":"report/#create-the-report-class","text":"On clinv/sources/ create your source class from this template. Substitute {{ class_name }} and {{ class_id }} with your values. \"\"\" Module to store the {{ class_name }}. Classes: {{ class_name }}: {{ class_description }} \"\"\" from clinv.reports import ClinvReport class {{ class_name }}( ClinvReport ): \"\"\" {{ class_description }} Parameters: inventory (Inventory): Clinv inventory object. Public methods: output: Print the report to stdout. Public attributes: inv (Inventory): Clinv inventory. \"\"\" def __init__ ( self , inventory ): super () . __init__ ( inventory ) def output ( self , resource_id ): \"\"\" Method to print the report to stdout. Parameters: resource_id (str): regular expression of a resource id. Returns: stdout: Resource information \"\"\"","title":"Create the report class"},{"location":"source/","text":"Source and Resource creation \u00b6 Create a new source \u00b6 A source is an abstraction from where we obtain resources and index them into our inventory. For the purpose of this section, we'll assume that the new source we want to add to our inventory is called newsource . If you want to see similar sources go to clinv/sources/ . Desired Interface \u00b6 To ensure the expected behavior of the sources, the class must follow a common interface. Don't worry if you don't understand yet what does each element mean, you'll discover it as you read the hole document. It must have the following attributes: id (str): ID of the resource. source_data (dict): Aggregated source supplied data. user_data (dict): Aggregated user supplied data. And the following public methods: generate_source_data: Generates the source_data attribute and returns it. generate_user_data: Generates the user_data attribute and returns it. generate_inventory: Generates the inventory dictionary with the source resource. Create the source test class \u00b6 On test/sources/ create your source class from this template. Substitute {{ class_name }} with your value. Also fill up the self.desired_source_data and self.desired_user_data with a representative template of the data you want to store into the inventory. from clinv.sources import {{ class_name }} src from tests.sources import ClinvSourceBaseTestClass import unittest class Test {{ class_name }} Source ( ClinvSourceBaseTestClass , unittest . TestCase ): ''' Test the {{ class_name }} implementation in the inventory. ''' def setUp ( self ): super () . setUp () self . source_obj = {{ class_name }} src # Initialize object to test source_data = {} user_data = {} self . src = self . source_obj ( source_data , user_data ) # What data we want to aggregate to our inventory self . desired_source_data = { } self . desired_user_data = { } self . src . source_data = self . desired_source_data def tearDown ( self ): super () . tearDown () def test_generate_source_data_creates_expected_source_data_attrib ( self ): # Mock here the call to your provider self . src . source_data = {} generated_source_data = self . src . generate_source_data () self . assertEqual ( self . src . source_data , self . desired_source_data , ) self . assertEqual ( generated_source_data , self . desired_source_data , ) @unittest . skip ( 'Not yet' ) def test_generate_user_data_creates_expected_user_data_attrib ( self ): generated_user_data = self . src . generate_user_data () self . assertEqual ( self . src . user_data , self . desired_user_data , ) self . assertEqual ( generated_user_data , self . desired_user_data , ) @unittest . skip ( 'Not yet' ) def test_generate_user_data_doesnt_loose_existing_data ( self ): user_key = [ key for key in self . desired_user_data . keys ()][ 0 ] desired_user_data = { user_key : {}} self . src . user_data = desired_user_data self . src . generate_user_data () self . assertEqual ( self . src . user_data , desired_user_data , ) @unittest . skip ( 'Not yet' ) def test_generate_inventory_return_empty_dict_if_no_data ( self ): self . src . source_data = {} self . assertEqual ( self . src . generate_inventory (), {}) @unittest . skip ( 'Not yet' ) @patch ( 'clinv.sources.{{ module_name }}.{{ class_name }}' ) def test_generate_inventory_creates_expected_dictionary ( self , resource_mock ): resource_id = '{{ resource_id }}' self . src . user_data = self . desired_user_data desired_mock_input = { ** self . src . user_data [ resource_id ], ** self . src . source_data [ resource_id ], } desired_inventory = self . src . generate_inventory () self . assertEqual ( resource_mock . assert_called_with ( { resource_id : desired_mock_input }, ), None , ) self . assertEqual ( desired_inventory , { resource_id : resource_mock . return_value }, ) Create the source class \u00b6 On clinv/sources/ create your source class from this template. Substitute {{ class_name }} and {{ class_id }} with your values. from clinv.sources import ClinvSourcesrc , ClinvGenericResource class {{ class_name }} src ( ClinvSourcesrc ): \"\"\" Class to gather and manipulate the {{ class_name }} resources. Parameters: source_data (dict): {{ class_name }}src compatible source_data dictionary. user_data (dict): {{ class_name }}src compatible user_data dictionary. Public methods: generate_source_data: Generates the source_data attribute and returns it. generate_user_data: Generates the user_data attribute and returns it. generate_inventory: Generates the inventory dictionary with the source resource. Public attributes: id (str): ID of the resource. source_data (dict): Aggregated source supplied data. user_data (dict): Aggregated user supplied data. log (logging object): \"\"\" def __init__ ( self , source_data = {}, user_data = {}): super () . __init__ ( source_data , user_data ) self . id = '{{ class_id }}' def generate_source_data ( self ): \"\"\" Do aggregation of the source data to generate the source dictionary into self.source_data, with the following structure: { } Returns: dict: content of self.source_data. \"\"\" self . log . info ( 'Fetching {{ class_name }} inventory' ) self . source_data = {} return self . source_data def generate_user_data ( self ): \"\"\" Do aggregation of the user data to populate the self.user_data attribute with the user_data.yaml information or with default values. It needs the information of self.source_data, therefore it should be called after generate_source_data. Returns: dict: content of self.user_data. \"\"\" return self . user_data def generate_inventory ( self ): \"\"\" Do aggregation of the user and source data to populate the self.inv attribute with {{ class_name }} resources. It needs the information of self.source_data and self.user_data, therefore it should be called after generate_source_data and generate_user_data. Returns: dict: {{ class_name }} inventory with user and source data \"\"\" inventory = {} for resource_id , resource in self . source_data . items (): # Load the user_data into the source_data record for key , value in self . user_data [ resource_id ] . items (): resource [ key ] = value inventory [ resource_id ] = {{ class_name }}({ resource_id : resource }) return inventory If you need to clean the dictionary created by your provider, use the self.prune_dictionary method. Create the generate_source_data method \u00b6 This method is meant to extract the information from your source, for example AWS and save it into the self.source_data , as well as return it. Create the generate_user_data method \u00b6 This method is meant to extract the information from the user, so it takes the resources saved on self.source_data and generates the basic template for each one and saves them into self.user_data . Create the generate_inventory method \u00b6 This method is meant to initiate the resource object of the source we're adding. This object doesn't exist yet, but we'll do that later. After initializing all the objects they are returned. Add your source to the loaded sources \u00b6 Import it in clinv/inventory.py and add it into the active_source_plugins variable Create the resource class \u00b6 On clinv/sources/ create your source class from this template. Substitute {{ class_name }} and {{ class_id }} with your values. class {{ class_name }}( ClinvGenericResource ): \"\"\" Class to extend the ClinvGenericResource abstract class. It gathers methods and attributes for the {{ class_name }} resources. Public methods: print: Prints information of the resource. Public properties: name: Returns the name of the record. \"\"\" def __init__ ( self , raw_data ): \"\"\" Execute the __init__ of the parent class ClinvActiveResource. \"\"\" super () . __init__ ( raw_data ) Create the resource test class \u00b6 class Test {{ class_name }}( ClinvGenericResourceTests , unittest . TestCase ): def setUp ( self ): self . module_name = '{{ module_name }}' self . id = '{{ class_id }}' super () . setUp () self . raw = { # Example of the dictionary to initialize the object. } self . resource = {{ class_name }}( self . raw ) def tearDown ( self ): super () . tearDown () Think if you can add more search filters in the object search method. Add resource to the reports \u00b6 There are some reports that are generic, such as list or print , but there are some that still aren't. So you'll need to manually add your resource to export and unassigned . Add resource to the cli \u00b6 For the reports that aren't generic add them in clinv/cli.py . Test that everything works \u00b6 Execute the following tasks Generate the new inventory clinv generate . Edit the use_data.yml . Regenerate the inventory and check that no information is lost. Check the different reports. Add documentation \u00b6 Complete the README.md and History.md","title":"Source and Resource creation"},{"location":"source/#source-and-resource-creation","text":"","title":"Source and Resource creation"},{"location":"source/#create-a-new-source","text":"A source is an abstraction from where we obtain resources and index them into our inventory. For the purpose of this section, we'll assume that the new source we want to add to our inventory is called newsource . If you want to see similar sources go to clinv/sources/ .","title":"Create a new source"},{"location":"source/#desired-interface","text":"To ensure the expected behavior of the sources, the class must follow a common interface. Don't worry if you don't understand yet what does each element mean, you'll discover it as you read the hole document. It must have the following attributes: id (str): ID of the resource. source_data (dict): Aggregated source supplied data. user_data (dict): Aggregated user supplied data. And the following public methods: generate_source_data: Generates the source_data attribute and returns it. generate_user_data: Generates the user_data attribute and returns it. generate_inventory: Generates the inventory dictionary with the source resource.","title":"Desired Interface"},{"location":"source/#create-the-source-test-class","text":"On test/sources/ create your source class from this template. Substitute {{ class_name }} with your value. Also fill up the self.desired_source_data and self.desired_user_data with a representative template of the data you want to store into the inventory. from clinv.sources import {{ class_name }} src from tests.sources import ClinvSourceBaseTestClass import unittest class Test {{ class_name }} Source ( ClinvSourceBaseTestClass , unittest . TestCase ): ''' Test the {{ class_name }} implementation in the inventory. ''' def setUp ( self ): super () . setUp () self . source_obj = {{ class_name }} src # Initialize object to test source_data = {} user_data = {} self . src = self . source_obj ( source_data , user_data ) # What data we want to aggregate to our inventory self . desired_source_data = { } self . desired_user_data = { } self . src . source_data = self . desired_source_data def tearDown ( self ): super () . tearDown () def test_generate_source_data_creates_expected_source_data_attrib ( self ): # Mock here the call to your provider self . src . source_data = {} generated_source_data = self . src . generate_source_data () self . assertEqual ( self . src . source_data , self . desired_source_data , ) self . assertEqual ( generated_source_data , self . desired_source_data , ) @unittest . skip ( 'Not yet' ) def test_generate_user_data_creates_expected_user_data_attrib ( self ): generated_user_data = self . src . generate_user_data () self . assertEqual ( self . src . user_data , self . desired_user_data , ) self . assertEqual ( generated_user_data , self . desired_user_data , ) @unittest . skip ( 'Not yet' ) def test_generate_user_data_doesnt_loose_existing_data ( self ): user_key = [ key for key in self . desired_user_data . keys ()][ 0 ] desired_user_data = { user_key : {}} self . src . user_data = desired_user_data self . src . generate_user_data () self . assertEqual ( self . src . user_data , desired_user_data , ) @unittest . skip ( 'Not yet' ) def test_generate_inventory_return_empty_dict_if_no_data ( self ): self . src . source_data = {} self . assertEqual ( self . src . generate_inventory (), {}) @unittest . skip ( 'Not yet' ) @patch ( 'clinv.sources.{{ module_name }}.{{ class_name }}' ) def test_generate_inventory_creates_expected_dictionary ( self , resource_mock ): resource_id = '{{ resource_id }}' self . src . user_data = self . desired_user_data desired_mock_input = { ** self . src . user_data [ resource_id ], ** self . src . source_data [ resource_id ], } desired_inventory = self . src . generate_inventory () self . assertEqual ( resource_mock . assert_called_with ( { resource_id : desired_mock_input }, ), None , ) self . assertEqual ( desired_inventory , { resource_id : resource_mock . return_value }, )","title":"Create the source test class"},{"location":"source/#create-the-source-class","text":"On clinv/sources/ create your source class from this template. Substitute {{ class_name }} and {{ class_id }} with your values. from clinv.sources import ClinvSourcesrc , ClinvGenericResource class {{ class_name }} src ( ClinvSourcesrc ): \"\"\" Class to gather and manipulate the {{ class_name }} resources. Parameters: source_data (dict): {{ class_name }}src compatible source_data dictionary. user_data (dict): {{ class_name }}src compatible user_data dictionary. Public methods: generate_source_data: Generates the source_data attribute and returns it. generate_user_data: Generates the user_data attribute and returns it. generate_inventory: Generates the inventory dictionary with the source resource. Public attributes: id (str): ID of the resource. source_data (dict): Aggregated source supplied data. user_data (dict): Aggregated user supplied data. log (logging object): \"\"\" def __init__ ( self , source_data = {}, user_data = {}): super () . __init__ ( source_data , user_data ) self . id = '{{ class_id }}' def generate_source_data ( self ): \"\"\" Do aggregation of the source data to generate the source dictionary into self.source_data, with the following structure: { } Returns: dict: content of self.source_data. \"\"\" self . log . info ( 'Fetching {{ class_name }} inventory' ) self . source_data = {} return self . source_data def generate_user_data ( self ): \"\"\" Do aggregation of the user data to populate the self.user_data attribute with the user_data.yaml information or with default values. It needs the information of self.source_data, therefore it should be called after generate_source_data. Returns: dict: content of self.user_data. \"\"\" return self . user_data def generate_inventory ( self ): \"\"\" Do aggregation of the user and source data to populate the self.inv attribute with {{ class_name }} resources. It needs the information of self.source_data and self.user_data, therefore it should be called after generate_source_data and generate_user_data. Returns: dict: {{ class_name }} inventory with user and source data \"\"\" inventory = {} for resource_id , resource in self . source_data . items (): # Load the user_data into the source_data record for key , value in self . user_data [ resource_id ] . items (): resource [ key ] = value inventory [ resource_id ] = {{ class_name }}({ resource_id : resource }) return inventory If you need to clean the dictionary created by your provider, use the self.prune_dictionary method.","title":"Create the source class"},{"location":"source/#create-the-generate_source_data-method","text":"This method is meant to extract the information from your source, for example AWS and save it into the self.source_data , as well as return it.","title":"Create the generate_source_data method"},{"location":"source/#create-the-generate_user_data-method","text":"This method is meant to extract the information from the user, so it takes the resources saved on self.source_data and generates the basic template for each one and saves them into self.user_data .","title":"Create the generate_user_data method"},{"location":"source/#create-the-generate_inventory-method","text":"This method is meant to initiate the resource object of the source we're adding. This object doesn't exist yet, but we'll do that later. After initializing all the objects they are returned.","title":"Create the generate_inventory method"},{"location":"source/#add-your-source-to-the-loaded-sources","text":"Import it in clinv/inventory.py and add it into the active_source_plugins variable","title":"Add your source to the loaded sources"},{"location":"source/#create-the-resource-class","text":"On clinv/sources/ create your source class from this template. Substitute {{ class_name }} and {{ class_id }} with your values. class {{ class_name }}( ClinvGenericResource ): \"\"\" Class to extend the ClinvGenericResource abstract class. It gathers methods and attributes for the {{ class_name }} resources. Public methods: print: Prints information of the resource. Public properties: name: Returns the name of the record. \"\"\" def __init__ ( self , raw_data ): \"\"\" Execute the __init__ of the parent class ClinvActiveResource. \"\"\" super () . __init__ ( raw_data )","title":"Create the resource class"},{"location":"source/#create-the-resource-test-class","text":"class Test {{ class_name }}( ClinvGenericResourceTests , unittest . TestCase ): def setUp ( self ): self . module_name = '{{ module_name }}' self . id = '{{ class_id }}' super () . setUp () self . raw = { # Example of the dictionary to initialize the object. } self . resource = {{ class_name }}( self . raw ) def tearDown ( self ): super () . tearDown () Think if you can add more search filters in the object search method.","title":"Create the resource test class"},{"location":"source/#add-resource-to-the-reports","text":"There are some reports that are generic, such as list or print , but there are some that still aren't. So you'll need to manually add your resource to export and unassigned .","title":"Add resource to the reports"},{"location":"source/#add-resource-to-the-cli","text":"For the reports that aren't generic add them in clinv/cli.py .","title":"Add resource to the cli"},{"location":"source/#test-that-everything-works","text":"Execute the following tasks Generate the new inventory clinv generate . Edit the use_data.yml . Regenerate the inventory and check that no information is lost. Check the different reports.","title":"Test that everything works"},{"location":"source/#add-documentation","text":"Complete the README.md and History.md","title":"Add documentation"},{"location":"todo/","text":"Todo \u00b6 HH \u00b6 H \u00b6 Add clinv verify to test: No user has changed it's policies attached No group has changed it's policies attached The group members are the ones that we desired Check if 2fa is enabled for users with password the access keys are updated Add IAM policy, roles and instance profiles support Add comments to ec2 instances, projects, services and informations M \u00b6 Add risk management support Autoscaling group support Add to clinv verify to check if there are deleted or terminated aws resources assigned to projects. Create an input method clinv create service Create an edit method clinv edit ser_01 Refactor the Source tests into a parent testcase to avoid duplicated code Service object access part divided by user type with each it's type of access and information it access Add related subcommand to get what resources are associated with a defined resource (with the optional -n flag to specify the levels of association) Improve service search so if the children resources match, the service matches. Search also into the terminated resources with a specific flag. But by default don't search on terminated (add a if self.state == terminated return False on ClinvGenericResource.search()). (refactor from list services) Read the description from the AWS resources L \u00b6 Automatic alphabetic reindex of informations, services and projects when c generate Terminated report that shows the resources of terminated services, to check if they should be destroyed Create the --json flag for reports","title":"Todo"},{"location":"todo/#todo","text":"","title":"Todo"},{"location":"todo/#hh","text":"","title":"HH"},{"location":"todo/#h","text":"Add clinv verify to test: No user has changed it's policies attached No group has changed it's policies attached The group members are the ones that we desired Check if 2fa is enabled for users with password the access keys are updated Add IAM policy, roles and instance profiles support Add comments to ec2 instances, projects, services and informations","title":"H"},{"location":"todo/#m","text":"Add risk management support Autoscaling group support Add to clinv verify to check if there are deleted or terminated aws resources assigned to projects. Create an input method clinv create service Create an edit method clinv edit ser_01 Refactor the Source tests into a parent testcase to avoid duplicated code Service object access part divided by user type with each it's type of access and information it access Add related subcommand to get what resources are associated with a defined resource (with the optional -n flag to specify the levels of association) Improve service search so if the children resources match, the service matches. Search also into the terminated resources with a specific flag. But by default don't search on terminated (add a if self.state == terminated return False on ClinvGenericResource.search()). (refactor from list services) Read the description from the AWS resources","title":"M"},{"location":"todo/#l","text":"Automatic alphabetic reindex of informations, services and projects when c generate Terminated report that shows the resources of terminated services, to check if they should be destroyed Create the --json flag for reports","title":"L"},{"location":"adr/001-refactor_to_domain_driven_design/","text":"Status \u00b6 Accepted Context \u00b6 The codebase of the project has grown old pretty fast, there are the next problems: The code structure doesn't comply with the domain driven design structure I'm using with the rest of my projects, that means that maintaining it is uncomfortable for me. I can't use the cookiecutter template to adapt the improvements I do on other projects. There is a high coupling between an adapter (aws) and the storage solution. I'm using argparse instead of click to define the cli A lot of the testing is done using mocks, instead of having a pyramid of unit and e2e tests. The model and service functionality is all mixed up in the models. The performance is bad when you have many resources. Proposals \u00b6 Refactor the code to use the domain driven design structure. Make it compliant with the cookiecutter python template . Migrate cli definition to click. Add type hints Decision \u00b6 Implement the only proposal Consequences \u00b6","title":"Status"},{"location":"adr/001-refactor_to_domain_driven_design/#status","text":"Accepted","title":"Status"},{"location":"adr/001-refactor_to_domain_driven_design/#context","text":"The codebase of the project has grown old pretty fast, there are the next problems: The code structure doesn't comply with the domain driven design structure I'm using with the rest of my projects, that means that maintaining it is uncomfortable for me. I can't use the cookiecutter template to adapt the improvements I do on other projects. There is a high coupling between an adapter (aws) and the storage solution. I'm using argparse instead of click to define the cli A lot of the testing is done using mocks, instead of having a pyramid of unit and e2e tests. The model and service functionality is all mixed up in the models. The performance is bad when you have many resources.","title":"Context"},{"location":"adr/001-refactor_to_domain_driven_design/#proposals","text":"Refactor the code to use the domain driven design structure. Make it compliant with the cookiecutter python template . Migrate cli definition to click. Add type hints","title":"Proposals"},{"location":"adr/001-refactor_to_domain_driven_design/#decision","text":"Implement the only proposal","title":"Decision"},{"location":"adr/001-refactor_to_domain_driven_design/#consequences","text":"","title":"Consequences"},{"location":"adr/adr/","text":"ADR are short text documents that captures an important architectural decision made along with its context and consequences.","title":"Adr"}]}